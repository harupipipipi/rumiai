修正: core_runtime/kernel.py
1) KernelConfig に Flow必須ポリシーと dev bootstrap を追加
Copy# --- 修正箇所: core_runtime/kernel.py ---

@dataclass
class KernelConfig:
    """Kernelの基本設定"""
    flow_path: str = "flow/project.flow.yaml"
    # FlowをSSOTとして必須にする（通常運用）
    require_flow: bool = True
    # 開発用: 明示的に許可された場合のみ Flow を自動生成して起動を助ける
    allow_dev_bootstrap: bool = False
    # allow_dev_bootstrap を環境変数でONにできる（明示的スイッチ）
    dev_bootstrap_env: str = "RUMI_DEV_BOOTSTRAP"
2) dev bootstrap 判定ヘルパーを追加
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel クラス内) ---

class Kernel:
    """Flow駆動の用途非依存カーネル"""

    def _dev_bootstrap_enabled(self) -> bool:
        try:
            if self.config.allow_dev_bootstrap:
                return True
            env_key = getattr(self.config, "dev_bootstrap_env", "RUMI_DEV_BOOTSTRAP")
            return str(os.getenv(env_key, "")).strip().lower() in ("1", "true", "yes", "on")
        except Exception:
            return False
3) load_flow()：ファイルが無い場合、通常は失敗（dev bootstrap時のみ生成）
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel.load_flow) ---

def load_flow(self, path: Optional[str] = None) -> Dict[str, Any]:
    """Flow(SSOT)を読み込む - Flow必須(既定) + 明示的dev bootstrapのみ自動生成"""
    flow_path = Path(path or self.config.flow_path)

    generated = False
    generated_from: Optional[str] = None

    # Flowが無い場合
    if not flow_path.exists():
        if self._dev_bootstrap_enabled():
            # 開発時のみ生成（上書きしない）
            try:
                flow_path.parent.mkdir(parents=True, exist_ok=True)
                flow_path.write_text(self._fallback_flow_a_yaml_text(), encoding="utf-8")
                generated = True
                generated_from = "fallback_A_dev_bootstrap"
            except Exception as e:
                self.diagnostics.record({
                    "ts": self._now_ts(),
                    "phase": "startup",
                    "step_id": "system.flow_autogenerate",
                    "handler": "kernel:flow.autogenerate",
                    "status": "failed",
                    "target": {"kind": "none", "id": None},
                    "error": {"type": type(e).__name__, "message": str(e)},
                    "meta": {"path": str(flow_path)},
                })
        else:
            # 通常運用: Flow必須なら失敗
            if getattr(self.config, "require_flow", True):
                self.diagnostics.record({
                    "ts": self._now_ts(),
                    "phase": "startup",
                    "step_id": "system.flow_load",
                    "handler": "kernel:flow.load",
                    "status": "failed",
                    "target": {"kind": "none", "id": None},
                    "error": {"type": "MissingFlow", "message": f"Flow file not found: {flow_path}"},
                    "meta": {
                        "path": str(flow_path),
                        "require_flow": True,
                        "hint": "Create flow/project.flow.yaml or set RUMI_DEV_BOOTSTRAP=1 for development bootstrap.",
                    },
                })
                raise FileNotFoundError(f"Flow file not found: {flow_path}")

    # Flow読み込み（壊れてたら fallback(A) へ。ただし require_flow=True の場合は原則失敗）
    try:
        raw = flow_path.read_text(encoding="utf-8")
        parsed, used_parser, parser_meta = self._parse_flow_text(raw)

        pipelines = parsed.get("pipelines")
        if not isinstance(pipelines, dict):
            raise ValueError("Flow must contain 'pipelines' object")
        if "startup" not in pipelines or "message" not in pipelines:
            raise ValueError("Flow.pipelines must contain 'startup' and 'message'")
        if not isinstance(pipelines.get("startup"), list) or not isinstance(pipelines.get("message"), list):
            raise ValueError("Flow.pipelines.startup/message must be lists")
        if "message_stream" in pipelines and not isinstance(pipelines.get("message_stream"), list):
            raise ValueError("Flow.pipelines.message_stream must be a list if present")

        self._flow = parsed
        flow_origin = "generated_dev_bootstrap" if generated else "user"

        self.diagnostics.record({
            "ts": self._now_ts(),
            "phase": "startup",
            "step_id": "system.flow_load",
            "handler": "kernel:flow.load",
            "status": "success",
            "target": {"kind": "none", "id": None},
            "error": None,
            "meta": {
                "path": str(flow_path),
                "generated": generated,
                "generated_from": generated_from,
                "flow_origin": flow_origin,
                "used_parser": used_parser,
                **parser_meta,
            },
        })

        return parsed

    except Exception as e:
        # require_flow=True の場合、壊れたFlowは fail-fast（ただしdev bootstrap時はfallback）
        if getattr(self.config, "require_flow", True) and not self._dev_bootstrap_enabled():
            self.diagnostics.record({
                "ts": self._now_ts(),
                "phase": "startup",
                "step_id": "system.flow_load",
                "handler": "kernel:flow.load",
                "status": "failed",
                "target": {"kind": "none", "id": None},
                "error": {"type": type(e).__name__, "message": str(e)},
                "meta": {
                    "path": str(flow_path),
                    "require_flow": True,
                    "hint": "Fix flow YAML/JSON. (Dev-only fallback is available via RUMI_DEV_BOOTSTRAP=1.)",
                },
            })
            raise

        # dev bootstrap 時のみ fallback(A)
        fallback = self._fallback_flow_a()
        self._flow = fallback

        self.diagnostics.record({
            "ts": self._now_ts(),
            "phase": "startup",
            "step_id": "system.flow_load",
            "handler": "kernel:flow.load",
            "status": "failed",
            "target": {"kind": "none", "id": None},
            "error": {"type": type(e).__name__, "message": str(e)},
            "meta": {
                "path": str(flow_path),
                "fallback": "A",
                "flow_origin": "generated_dev_bootstrap" if generated else "user",
            },
        })

        return fallback
4) run_startup/run_message/run_message_stream：Flow必須失敗を“診断付きで返す”
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel.run_startup/run_message/run_message_stream) ---

def run_startup(self) -> Dict[str, Any]:
    """Startup Pipelineを実行する(Flow準拠)"""
    try:
        flow = self._flow or self.load_flow()
    except Exception as e:
        self.diagnostics.record_step(
            phase="startup",
            step_id="startup.pipeline.flow_unavailable",
            handler="kernel:startup.run",
            status="failed",
            error=e,
            meta={"hint": "Flow is required. Provide flow/project.flow.yaml (or dev bootstrap)."},
        )
        return self.diagnostics.as_dict()
    # （以下は既存のまま）

def run_message(self, chat_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    """Message Pipelineを実行する(Flow準拠)"""
    try:
        flow = self._flow or self.load_flow()
    except Exception as e:
        self.diagnostics.record_step(
            phase="message",
            step_id="message.pipeline.flow_unavailable",
            handler="kernel:message.run",
            status="failed",
            error=e,
            meta={"chat_id": chat_id, "hint": "Flow is required."},
        )
        return {"success": False, "error": "Flow unavailable", "details": str(e), "chat_id": chat_id}
    # （以下は既存のまま）

def run_message_stream(self, chat_id: str, payload: Dict[str, Any]) -> Any:
    """Message Stream Pipelineを実行する(Flow準拠)"""
    try:
        flow = self._flow or self.load_flow()
    except Exception as e:
        self.diagnostics.record_step(
            phase="message",
            step_id="message_stream.pipeline.flow_unavailable",
            handler="kernel:message_stream.run",
            status="failed",
            error=e,
            meta={"chat_id": chat_id, "hint": "Flow is required."},
        )
        # streaming時はdictを返しても良い（呼び出し側がResponseにしない場合の保険）
        return {"success": False, "error": "Flow unavailable", "details": str(e), "chat_id": chat_id}
    # （以下は既存のまま）
5) fallback flow(A) の interface_key を新設計に合わせる（message.handle）
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel._fallback_flow_a) ---

"message": [
    {"id": "message.context_assemble", "run": {"handler": "kernel:context.assemble", "args": {}}, "optional": True, "on_error": {"action": "continue"}},
    {"id": "message.invoke", "run": {"handler": "kernel:delegate.call", "args": {"interface_key": "message.handle"}}, "optional": False, "on_error": {"action": "continue"}},
    {"id": "message.persist", "run": {"handler": "kernel:persist", "args": {"targets": ["history", "ui_history", "chat_config"]}}, "optional": True, "on_error": {"action": "continue"}},
    {"id": "message.output", "run": {"handler": "kernel:output", "args": {"mode": "auto"}}, "optional": True, "on_error": {"action": "continue"}},
],
"message_stream": [
    {"id": "message_stream.context_assemble", "run": {"handler": "kernel:context.assemble", "args": {}}, "optional": True, "on_error": {"action": "continue"}},
    {"id": "message_stream.invoke", "run": {"handler": "kernel:delegate.call", "args": {"interface_key": "message.handle_stream"}}, "optional": False, "on_error": {"action": "continue"}},
    {"id": "message_stream.persist", "run": {"handler": "kernel:persist", "args": {"targets": ["history", "ui_history", "chat_config"]}}, "optional": True, "on_error": {"action": "continue"}},
    {"id": "message_stream.output", "run": {"handler": "kernel:output", "args": {"mode": "auto"}}, "optional": True, "on_error": {"action": "continue"}},
],
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel._fallback_flow_a_yaml_text) ---

  message:
    - id: "message.context_assemble"
      run:
        handler: "kernel:context.assemble"
        args: {}
      optional: true
      on_error: { action: "continue" }
    - id: "message.invoke"
      run:
        handler: "kernel:delegate.call"
        args:
          interface_key: "message.handle"
      optional: false
      on_error: { action: "continue" }
    - id: "message.persist"
      run:
        handler: "kernel:persist"
        args:
          targets: ["history", "ui_history", "chat_config"]
      optional: true
      on_error: { action: "continue" }
    - id: "message.output"
      run:
        handler: "kernel:output"
        args: { mode: "auto" }
      optional: true
      on_error: { action: "continue" }
  message_stream:
    - id: "message_stream.context_assemble"
      run:
        handler: "kernel:context.assemble"
        args: {}
      optional: true
      on_error: { action: "continue" }
    - id: "message_stream.invoke"
      run:
        handler: "kernel:delegate.call"
        args:
          interface_key: "message.handle_stream"
      optional: false
      on_error: { action: "continue" }
    - id: "message_stream.persist"
      run:
        handler: "kernel:persist"
        args:
          targets: ["history", "ui_history", "chat_config"]
      optional: true
      on_error: { action: "continue" }
    - id: "message_stream.output"
      run:
        handler: "kernel:output"
        args: { mode: "auto" }
      optional: true
      on_error: { action: "continue" }



修正: core_runtime/kernel.py
1) dev bootstrap が書き出すテキストを「JSON（=PyYAML不要）」に固定するヘルパー追加
Copy# --- 追加/修正箇所: core_runtime/kernel.py (Kernel クラス内、_fallback_flow_a_yaml_text の近く) ---

def _fallback_flow_a_bootstrap_text(self) -> str:
    """
    dev bootstrap 用に Flow テキストを生成する。
    重要:
    - PyYAML 未導入でも必ずパース可能にするため JSON を出力する
    - 内容は常に _fallback_flow_a() から生成し、text版との差分/欠落を防ぐ
    """
    return json.dumps(self._fallback_flow_a(), ensure_ascii=False, indent=2)
これで「YAML固定で生成→PyYAML無しで読めない」問題を解消します。拡張子が .yaml でも中身が JSON なら、PyYAMLが無くても json.loads で読めます（あなたの _parse_flow_text は JSON fallback を持っている）。

2) load_flow() の dev bootstrap 書き込みを JSON に切替 + “生成したのに読めない”時の再試行と診断を明確化
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel.load_flow 内の「dev bootstrap で生成」ブロック) ---

if not flow_path.exists():
    if self._dev_bootstrap_enabled():
        # 開発時のみ生成（上書きしない）
        try:
            flow_path.parent.mkdir(parents=True, exist_ok=True)

            # NOTE: PyYAML不要にするため JSON を書く（拡張子は.yamlでもOK）
            flow_path.write_text(self._fallback_flow_a_bootstrap_text(), encoding="utf-8")

            generated = True
            generated_from = "fallback_A_dev_bootstrap_json"
        except Exception as e:
            ...
    else:
        ...
そして、同じ load_flow() の Flow読み込み try ブロックの直後に、以下の「生成済みFlowの再修復」リトライを入れます（1回だけ）：

Copy# --- 修正箇所: core_runtime/kernel.py (Kernel.load_flow の「Flow読み込み try/except」部分の except 内) ---

except Exception as e:
    # require_flow=True の場合、壊れたFlowは fail-fast（ただしdev bootstrap時は修復を一度だけ試す）
    if getattr(self.config, "require_flow", True) and not self._dev_bootstrap_enabled():
        ...
        raise

    # dev bootstrap 時：生成したファイルが読めないケースを明示的に扱う
    if self._dev_bootstrap_enabled():
        # もし生成直後のファイルが読めていないなら、JSONで“修復上書き→再パース”を1回試す
        repaired = False
        try:
            if flow_path.exists():
                flow_path.write_text(self._fallback_flow_a_bootstrap_text(), encoding="utf-8")
                repaired = True

                raw2 = flow_path.read_text(encoding="utf-8")
                parsed2, used_parser2, parser_meta2 = self._parse_flow_text(raw2)

                pipelines2 = parsed2.get("pipelines")
                if not isinstance(pipelines2, dict):
                    raise ValueError("Flow must contain 'pipelines' object")
                if "startup" not in pipelines2 or "message" not in pipelines2:
                    raise ValueError("Flow.pipelines must contain 'startup' and 'message'")
                if not isinstance(pipelines2.get("startup"), list) or not isinstance(pipelines2.get("message"), list):
                    raise ValueError("Flow.pipelines.startup/message must be lists")
                if "message_stream" in pipelines2 and not isinstance(pipelines2.get("message_stream"), list):
                    raise ValueError("Flow.pipelines.message_stream must be a list if present")

                self._flow = parsed2
                self.diagnostics.record({
                    "ts": self._now_ts(),
                    "phase": "startup",
                    "step_id": "system.flow_repair",
                    "handler": "kernel:flow.repair",
                    "status": "success",
                    "target": {"kind": "none", "id": None},
                    "error": None,
                    "meta": {
                        "path": str(flow_path),
                        "repaired": True,
                        "repaired_format": "json",
                        "used_parser": used_parser2,
                        **parser_meta2,
                    },
                })
                return parsed2
        except Exception as e2:
            # 修復失敗：この時点でのみ “内部fallback” を使うが、必ず診断に残す
            self.diagnostics.record({
                "ts": self._now_ts(),
                "phase": "startup",
                "step_id": "system.flow_repair",
                "handler": "kernel:flow.repair",
                "status": "failed",
                "target": {"kind": "none", "id": None},
                "error": {"type": type(e2).__name__, "message": str(e2)},
                "meta": {
                    "path": str(flow_path),
                    "repaired_attempted": True,
                    "note": "Dev bootstrap flow could not be parsed even after JSON rewrite; using in-memory fallback to continue.",
                },
            })

    # dev bootstrap 時のみ fallback(A)（不透明にならないよう diagnostics で明示済み）
    fallback = self._fallback_flow_a()
    self._flow = fallback

    self.diagnostics.record({
        "ts": self._now_ts(),
        "phase": "startup",
        "step_id": "system.flow_load",
        "handler": "kernel:flow.load",
        "status": "failed",
        "target": {"kind": "none", "id": None},
        "error": {"type": type(e).__name__, "message": str(e)},
        "meta": {
            "path": str(flow_path),
            "fallback": "A_in_memory",
            "reason": "dev_bootstrap_parse_failed",
            "flow_origin": "generated_dev_bootstrap" if generated else "user",
        },
    })

    return fallback
これで「生成はされたが読めない→内部fallbackで動く」という挙動が起きても、必ず diagnostics に “repair失敗→in-memory fallback使用” が残るため不透明になりません。
また “生成したが読めない” そのものも、最初から JSON 書き出しに変えたことで、ほぼ起きなくなります。

3) _fallback_flow_a_yaml_text() 由来の “message/message_stream が空” ドリフトを根絶する
あなたの懸念は「text側が空のまま残るリスク」です。上の _fallback_flow_a_bootstrap_text() は _fallback_flow_a() から生成するので、辞書側に正しいpipelineが入っていれば textは必ず一致します。
よって、bootstrapで _fallback_flow_a_yaml_text() を二度と使わないことが根本解です（今回それを実施）。

ただし、既存の _fallback_flow_a_yaml_text() が残っていると混乱するので、内容を “辞書から生成” に寄せます（関数名は互換のため残す）。

Copy# --- 修正箇所: core_runtime/kernel.py (_fallback_flow_a_yaml_text の実装) ---

def _fallback_flow_a_yaml_text(self) -> str:
    """
    互換のため残すが、内容は _fallback_flow_a() から生成する。
    注意: 現状は YAML ではなく JSON を返す（PyYAML不要・ドリフト防止）。
    """
    return self._fallback_flow_a_bootstrap_text()
これで「_fallback_flow_a_yaml_text の message/message_stream が空のまま」リスクが構造的に消えます。
将来的に本当にYAMLで出したくなったら、PyYAMLがあるときだけYAML、無ければJSON、のように分岐すればOKです。

修正: core_runtime/kernel.py
1) dev bootstrap が書き出すテキストを「JSON（=PyYAML不要）」に固定するヘルパー追加
Copy# --- 追加/修正箇所: core_runtime/kernel.py (Kernel クラス内、_fallback_flow_a_yaml_text の近く) ---

def _fallback_flow_a_bootstrap_text(self) -> str:
    """
    dev bootstrap 用に Flow テキストを生成する。
    重要:
    - PyYAML 未導入でも必ずパース可能にするため JSON を出力する
    - 内容は常に _fallback_flow_a() から生成し、text版との差分/欠落を防ぐ
    """
    return json.dumps(self._fallback_flow_a(), ensure_ascii=False, indent=2)
これで「YAML固定で生成→PyYAML無しで読めない」問題を解消します。拡張子が .yaml でも中身が JSON なら、PyYAMLが無くても json.loads で読めます（あなたの _parse_flow_text は JSON fallback を持っている）。

2) load_flow() の dev bootstrap 書き込みを JSON に切替 + “生成したのに読めない”時の再試行と診断を明確化
Copy# --- 修正箇所: core_runtime/kernel.py (Kernel.load_flow 内の「dev bootstrap で生成」ブロック) ---

if not flow_path.exists():
    if self._dev_bootstrap_enabled():
        # 開発時のみ生成（上書きしない）
        try:
            flow_path.parent.mkdir(parents=True, exist_ok=True)

            # NOTE: PyYAML不要にするため JSON を書く（拡張子は.yamlでもOK）
            flow_path.write_text(self._fallback_flow_a_bootstrap_text(), encoding="utf-8")

            generated = True
            generated_from = "fallback_A_dev_bootstrap_json"
        except Exception as e:
            ...
    else:
        ...
そして、同じ load_flow() の Flow読み込み try ブロックの直後に、以下の「生成済みFlowの再修復」リトライを入れます（1回だけ）：

Copy# --- 修正箇所: core_runtime/kernel.py (Kernel.load_flow の「Flow読み込み try/except」部分の except 内) ---

except Exception as e:
    # require_flow=True の場合、壊れたFlowは fail-fast（ただしdev bootstrap時は修復を一度だけ試す）
    if getattr(self.config, "require_flow", True) and not self._dev_bootstrap_enabled():
        ...
        raise

    # dev bootstrap 時：生成したファイルが読めないケースを明示的に扱う
    if self._dev_bootstrap_enabled():
        # もし生成直後のファイルが読めていないなら、JSONで“修復上書き→再パース”を1回試す
        repaired = False
        try:
            if flow_path.exists():
                flow_path.write_text(self._fallback_flow_a_bootstrap_text(), encoding="utf-8")
                repaired = True

                raw2 = flow_path.read_text(encoding="utf-8")
                parsed2, used_parser2, parser_meta2 = self._parse_flow_text(raw2)

                pipelines2 = parsed2.get("pipelines")
                if not isinstance(pipelines2, dict):
                    raise ValueError("Flow must contain 'pipelines' object")
                if "startup" not in pipelines2 or "message" not in pipelines2:
                    raise ValueError("Flow.pipelines must contain 'startup' and 'message'")
                if not isinstance(pipelines2.get("startup"), list) or not isinstance(pipelines2.get("message"), list):
                    raise ValueError("Flow.pipelines.startup/message must be lists")
                if "message_stream" in pipelines2 and not isinstance(pipelines2.get("message_stream"), list):
                    raise ValueError("Flow.pipelines.message_stream must be a list if present")

                self._flow = parsed2
                self.diagnostics.record({
                    "ts": self._now_ts(),
                    "phase": "startup",
                    "step_id": "system.flow_repair",
                    "handler": "kernel:flow.repair",
                    "status": "success",
                    "target": {"kind": "none", "id": None},
                    "error": None,
                    "meta": {
                        "path": str(flow_path),
                        "repaired": True,
                        "repaired_format": "json",
                        "used_parser": used_parser2,
                        **parser_meta2,
                    },
                })
                return parsed2
        except Exception as e2:
            # 修復失敗：この時点でのみ “内部fallback” を使うが、必ず診断に残す
            self.diagnostics.record({
                "ts": self._now_ts(),
                "phase": "startup",
                "step_id": "system.flow_repair",
                "handler": "kernel:flow.repair",
                "status": "failed",
                "target": {"kind": "none", "id": None},
                "error": {"type": type(e2).__name__, "message": str(e2)},
                "meta": {
                    "path": str(flow_path),
                    "repaired_attempted": True,
                    "note": "Dev bootstrap flow could not be parsed even after JSON rewrite; using in-memory fallback to continue.",
                },
            })

    # dev bootstrap 時のみ fallback(A)（不透明にならないよう diagnostics で明示済み）
    fallback = self._fallback_flow_a()
    self._flow = fallback

    self.diagnostics.record({
        "ts": self._now_ts(),
        "phase": "startup",
        "step_id": "system.flow_load",
        "handler": "kernel:flow.load",
        "status": "failed",
        "target": {"kind": "none", "id": None},
        "error": {"type": type(e).__name__, "message": str(e)},
        "meta": {
            "path": str(flow_path),
            "fallback": "A_in_memory",
            "reason": "dev_bootstrap_parse_failed",
            "flow_origin": "generated_dev_bootstrap" if generated else "user",
        },
    })

    return fallback
これで「生成はされたが読めない→内部fallbackで動く」という挙動が起きても、必ず diagnostics に “repair失敗→in-memory fallback使用” が残るため不透明になりません。
また “生成したが読めない” そのものも、最初から JSON 書き出しに変えたことで、ほぼ起きなくなります。

3) _fallback_flow_a_yaml_text() 由来の “message/message_stream が空” ドリフトを根絶する
あなたの懸念は「text側が空のまま残るリスク」です。上の _fallback_flow_a_bootstrap_text() は _fallback_flow_a() から生成するので、辞書側に正しいpipelineが入っていれば textは必ず一致します。
よって、bootstrapで _fallback_flow_a_yaml_text() を二度と使わないことが根本解です（今回それを実施）。

ただし、既存の _fallback_flow_a_yaml_text() が残っていると混乱するので、内容を “辞書から生成” に寄せます（関数名は互換のため残す）。

Copy# --- 修正箇所: core_runtime/kernel.py (_fallback_flow_a_yaml_text の実装) ---

def _fallback_flow_a_yaml_text(self) -> str:
    """
    互換のため残すが、内容は _fallback_flow_a() から生成する。
    注意: 現状は YAML ではなく JSON を返す（PyYAML不要・ドリフト防止）。
    """
    return self._fallback_flow_a_bootstrap_text()
これで「_fallback_flow_a_yaml_text の message/message_stream が空のまま」リスクが構造的に消えます。
将来的に本当にYAMLで出したくなったら、PyYAMLがあるときだけYAML、無ければJSON、のように分岐すればOKです。


修正: app.py
1) Kernel の HTTP binder 適用用フラグ/ロックを追加
Copy# --- 修正箇所: app = Flask(__name__) の直後あたり ---

# --- Kernel (Flow-driven OS) ---
_kernel = None  # fail-soft: Kernelが初期化できなくてもアプリは起動する
_kernel_started = False  # プロセス内ガード（WSGI/リロードでの多重実行を抑制）
_kernel_start_error = None
_kernel_start_lock = threading.Lock()
_kernel_interfaces_registered = False
_kernel_if_lock = threading.Lock()

# 追加: ecosystem 側から提供される HTTP binders 適用ガード
_kernel_http_binders_applied = False
_kernel_http_lock = threading.Lock()
_kernel_http_apply_error = None
2) tool/prompt を app.py で sys.path に入れるのを停止（贔屓排除）
Copy# --- 修正箇所: 既存の sys.path.insert(0, tool/prompt) ブロックを削除/無効化 ---

# パスを追加（tool/ と prompt/ を参照可能にする）
# _project_root = Path(__file__).parent
# sys.path.insert(0, str(_project_root / "tool"))
# sys.path.insert(0, str(_project_root / "prompt"))
ここは「公式が tool/prompt を知っている」状態を作るので停止します。
以後は ecosystem の component が必要なら自分で解決します（今回作った bridge_message は動的importで対応済み）。

3) ensure_kernel_interfaces_registered() を実質 no-op 化（app.py から参照実装登録しない）
Copy# --- 修正箇所: ensure_kernel_interfaces_registered を差し替え ---

def ensure_kernel_interfaces_registered():
    """
    互換用に関数名は残すが、app.py ではインターフェース登録を行わない。

    理由:
    - 参照実装の登録は ecosystem component の責務（公式が贔屓しないため）
    - message.handle / io.http.binders 等は component_phase:setup で登録される想定
    """
    global _kernel_interfaces_registered
    _kernel_interfaces_registered = True
    return
既存の before_request から呼ばれていても問題なく通ります。

4) ecosystem の io.http.binders を app に適用する関数を追加
Copy# --- 修正箇所: ensure_kernel_started() の後あたりに追加 ---

def ensure_http_binders_applied():
    """
    ecosystem が InterfaceRegistry に登録した io.http.binders を Flask app に適用する。
    - 1プロセスで1回だけ
    - fail-soft（binder側の例外で全体が死なない）
    """
    global _kernel_http_binders_applied, _kernel_http_apply_error

    if _kernel_http_binders_applied:
        return
    if _kernel is None:
        return

    with _kernel_http_lock:
        if _kernel_http_binders_applied:
            return

        try:
            binders = _kernel.interface_registry.get("io.http.binders", strategy="all")
            if binders is None:
                binders = []
            if not isinstance(binders, list):
                binders = [binders]

            applied = 0
            for b in binders:
                if callable(b):
                    try:
                        b(app, _kernel, {"app": app})
                        applied += 1
                    except Exception as e:
                        print(f"[Kernel][io.http] binder failed (fail-soft): {e}")
                        traceback.print_exc()

            print(f"[Kernel][io.http] applied binders: {applied}")
            _kernel_http_apply_error = None
        except Exception as e:
            _kernel_http_apply_error = str(e)
            print(f"[Kernel][io.http] apply failed (fail-soft): {e}")
            traceback.print_exc()
        finally:
            _kernel_http_binders_applied = True
5) before_request で binder 適用も行う（WSGI/リローダ環境の保険）
Copy# --- 修正箇所: @app.before_request の中 ---

@app.before_request
def _ensure_kernel_before_request():
    # リクエストが来たプロセスで一度だけ起動する
    ensure_kernel_started()
    ensure_kernel_interfaces_registered()
    ensure_http_binders_applied()
6) 起動時（import時）にも可能なら binder を適用（最初のリクエストを待たない）
※WSGI/リローダでの多重は既存ガードで抑制されます。

Copy# --- 修正箇所: before_request 定義の直後あたりに追加（fail-soft） ---

# import時点で可能なら一度だけ起動・binder適用を試す（fail-soft）
try:
    ensure_kernel_started()
    ensure_http_binders_applied()
except Exception as _e:
    # fail-soft
    pass


修正: app.py
1) HTTP binder 適用の状態管理を拡張（attempt時刻/間隔）
Copy# --- 修正箇所: Kernelグローバル付近（_kernel_http_* 変数群） ---

_kernel_http_binders_applied = False
_kernel_http_lock = threading.Lock()
_kernel_http_apply_error = None

# 追加: binder 適用の再試行制御（0件のときに毎回探しに行かない）
_kernel_http_last_apply_attempt = 0.0
_kernel_http_min_attempt_interval_sec = 1.0
2) import時に Kernel 起動/ binder 適用を試すブロックを削除（lazy徹底）
Copy# --- 修正箇所: このブロックを削除してください（完全削除） ---
# # import時点で可能なら一度だけ起動・binder適用を試す（fail-soft）
# try:
#     ensure_kernel_started()
#     ensure_http_binders_applied()
# except Exception as _e:
#     # fail-soft
#     pass
3) ensure_http_binders_applied() を「0件ならフラグを立てない」「スロットリング付き」に修正
Copy# --- 修正箇所: ensure_http_binders_applied() 関数を置き換え ---

def ensure_http_binders_applied():
    """
    ecosystem が InterfaceRegistry に登録した io.http.binders を Flask app に適用する。

    修正方針:
    - lazy徹底: import時には呼ばず、request時にだけ試みる
    - binderが0件なら applied フラグを立てない（後から登録された binder を拾える）
    - 毎リクエストで無限に探しに行かないよう、軽いスロットリングを入れる
    """
    global _kernel_http_binders_applied, _kernel_http_apply_error, _kernel_http_last_apply_attempt

    if _kernel_http_binders_applied:
        return
    if _kernel is None:
        return

    now = time.time()
    # スロットリング（ロック外で軽く弾く）
    if (now - _kernel_http_last_apply_attempt) < _kernel_http_min_attempt_interval_sec:
        return

    with _kernel_http_lock:
        if _kernel_http_binders_applied:
            return

        now2 = time.time()
        if (now2 - _kernel_http_last_apply_attempt) < _kernel_http_min_attempt_interval_sec:
            return
        _kernel_http_last_apply_attempt = now2

        try:
            binders = _kernel.interface_registry.get("io.http.binders", strategy="all")
            if binders is None:
                binders = []
            if not isinstance(binders, list):
                binders = [binders]

            # callableだけ抽出
            binders = [b for b in binders if callable(b)]

            if not binders:
                # 0件なら「未適用」のまま。後で component が登録したら適用できる。
                _kernel_http_apply_error = "no io.http.binders registered yet"
                return

            applied = 0
            for b in binders:
                try:
                    b(app, _kernel, {"app": app})
                    applied += 1
                except Exception as e:
                    print(f"[Kernel][io.http] binder failed (fail-soft): {e}")
                    traceback.print_exc()

            if applied > 0:
                _kernel_http_binders_applied = True
                _kernel_http_apply_error = None
                print(f"[Kernel][io.http] applied binders: {applied}")
            else:
                # binderは存在するが全部失敗した → 後で直った可能性に備えて未適用のまま
                _kernel_http_apply_error = "io.http.binders exist but all failed to apply"
        except Exception as e:
            _kernel_http_apply_error = str(e)
            print(f"[Kernel][io.http] apply failed (fail-soft): {e}")
            traceback.print_exc()
            # 例外でも未適用のまま（後で回復できる）
4) （任意だが推奨）startup成功直後に binder 適用を一度だけ試す（ただし lazy: “最初のリクエスト時”の中で）
ensure_kernel_started() の中で _kernel.run_startup() が成功した直後に ensure_http_binders_applied() を呼ぶと、同一リクエスト内で binder が即適用されます（ただし before_request 自体は binder 追加後に再実行されないので、最初のリクエストから新ルートで捌くことはできません。次リクエストから有効になります）。それでも “起動順の確実性” が上がるので入れておきます。

Copy# --- 修正箇所: ensure_kernel_started() の _kernel.run_startup() 直後あたりに追加 ---

            _kernel.run_startup()
            _kernel_start_error = None
            print("[Kernel] Startup pipeline executed (lazy)")

            # 追加: startup後に一度だけHTTP binder適用を試みる（fail-soft）
            try:
                ensure_http_binders_applied()
            except Exception as e:
                print(f"[Kernel][io.http] apply after startup failed (fail-soft): {e}")

Step 5-A（新規）: io_http_chats_v1 コンポーネントを追加
新規: ecosystem/default/backend/components/io_http_chats/manifest.json
Copy{
  "type": "io",
  "id": "io_http_chats_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Chat/Folder/UI history API を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_chats/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Tuple
import traceback


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_chats.register",
                handler="io_http_chats:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def _lazy_get_managers() -> Tuple[Any, Any]:
        """
        既存（移行中）の ChatManager / RelationshipManager を遅延 import で取得。
        後で chats_service / relationship_service に差し替える前提。
        """
        from chat_manager import ChatManager
        from relationship_manager import RelationshipManager
        return ChatManager(), RelationshipManager()

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        """
        Flask app に chats 系 API を追加する binder。
        二重登録を避けるため、blueprint 名で idempotent にする。
        """
        if "rumi_io_http_chats_v1" in getattr(app, "blueprints", {}):
            return

        from flask import Blueprint, request, jsonify

        bp = Blueprint("rumi_io_http_chats_v1", __name__)

        # -----------------------
        # folders
        # -----------------------
        @bp.post("/api/folders")
        def create_folder():
            data = request.get_json(silent=True) or {}
            folder_name = (data.get("name") or "").strip()

            chat_manager, _ = _lazy_get_managers()
            try:
                folder_name2 = chat_manager.create_folder(folder_name)
                return jsonify({"success": True, "folder_name": folder_name2}), 201
            except ValueError as e:
                return jsonify({"error": str(e)}), 400
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        # -----------------------
        # chats list/create
        # -----------------------
        @bp.get("/api/chats")
        def get_all_chats():
            chat_manager, _ = _lazy_get_managers()
            return jsonify(chat_manager.get_all_chats())

        @bp.post("/api/chats")
        def create_new_chat():
            data = request.get_json(silent=True) or {}
            folder_name = data.get("folder", None)

            chat_manager, _ = _lazy_get_managers()
            metadata = chat_manager.create_chat(folder_name)
            return jsonify(metadata), 201

        # -----------------------
        # single chat
        # -----------------------
        @bp.route("/api/chats/<chat_id>", methods=["GET", "DELETE", "PATCH"])
        def handle_single_chat(chat_id: str):
            chat_manager, relationship_manager = _lazy_get_managers()

            if request.method == "DELETE":
                try:
                    deleted_links = relationship_manager.delete_all_links_for(chat_id)
                    if deleted_links > 0:
                        print(f"Deleted {deleted_links} relationship links for chat {chat_id}")

                    chat_manager.delete_chat(chat_id)
                    return jsonify({"success": True}), 200
                except FileNotFoundError:
                    return jsonify({"error": "Chat not found"}), 404
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            if request.method == "GET":
                try:
                    data = chat_manager.load_chat_history(chat_id)
                    return jsonify(data)
                except FileNotFoundError:
                    return jsonify({
                        "metadata": {"title": "新しいチャット", "is_pinned": False, "folder": None},
                        "messages": []
                    })

            # PATCH
            try:
                chat_manager.update_chat_metadata(chat_id, request.json)
                return jsonify({"success": True}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        # -----------------------
        # copy chat
        # -----------------------
        @bp.post("/api/chats/<chat_id>/copy")
        def copy_chat(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                new_chat_id = chat_manager.copy_chat(chat_id)
                return jsonify({"success": True, "new_chat_id": new_chat_id}), 201
            except FileNotFoundError:
                return jsonify({"error": "Source chat not found"}), 404
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        # -----------------------
        # UI history (tool logs + ui_state)
        # -----------------------
        @bp.get("/api/chats/<chat_id>/ui_history")
        def get_ui_history(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                ui_data = chat_manager.load_ui_history(chat_id)
                return jsonify(ui_data), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @bp.get("/api/chats/<chat_id>/ui_history/logs")
        def get_ui_history_logs(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                ui_data = chat_manager.load_ui_history(chat_id)
                execution_id = request.args.get("execution_id")
                if execution_id:
                    logs = chat_manager.get_tool_logs_for_execution(chat_id, execution_id)
                else:
                    logs = ui_data.get("tool_logs", [])
                return jsonify({"logs": logs}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @bp.post("/api/chats/<chat_id>/ui_history/append_log")
        def append_ui_log(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                log_entry = request.get_json(silent=True) or {}
                message_id = chat_manager.append_tool_log(chat_id, log_entry)
                return jsonify({"success": True, "message_id": message_id}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @bp.route("/api/chats/<chat_id>/ui_history/state", methods=["GET", "POST"])
        def handle_ui_state(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                if request.method == "GET":
                    ui_data = chat_manager.load_ui_history(chat_id)
                    return jsonify({"ui_state": ui_data.get("ui_state", {})}), 200

                state_updates = request.get_json(silent=True) or {}
                for key, value in state_updates.items():
                    chat_manager.update_ui_state(chat_id, key, value)
                return jsonify({"success": True}), 200

            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @bp.delete("/api/chats/<chat_id>/ui_history/clear")
        def clear_ui_history(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                chat_manager.clear_ui_history(chat_id)
                return jsonify({"success": True}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        # Blueprint 登録
        app.register_blueprint(bp)

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_chats_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_chats.register",
            handler="io_http_chats:setup",
            status="success",
            meta={"registered": ["io.http.binders"], "routes": "chats/folders/ui_history/copy"},
        )
Step 5-B（既存修正）: app.py から chats 系ルートを削除
以下の ルート定義ブロックを削除してください（ecosystem io_http_chats_v1 が同等機能を提供します）。

app.py 修正（削除する範囲の指定）
削除対象1: folders + chats CRUD + copy
削除開始：この行から

Copy@app.route('/api/folders', methods=['POST'])
def create_folder():
削除終了：この関数ブロックの直後まで（次の “UI履歴関連のエンドポイント” コメントの直前まで）
具体的には、次の関数群をまとめて削除します：

create_folder
get_all_chats（GET /api/chats）
create_new_chat（POST /api/chats）
handle_single_chat（GET/DELETE/PATCH /api/chats/<chat_id>）
handle_chat_tools（GET/POST /api/chats/<chat_id>/tools）※これは tools 系に近いですが、chat配下なので一旦こちらに含めて削除（次ステップで io_http_tools_chatconfig としてecosystemへ移します）
copy_chat（POST /api/chats/<chat_id>/copy）
handle_chat_tools を削除するため、UI側がこのAPIを使っている場合は次ステップで ecosystem 側に同等APIを追加します（すぐ続けます）。

削除対象2: UI履歴関連（ui_history 一式）
削除開始：この行から

Copy# UI履歴関連のエンドポイント
@app.route('/api/chats/<chat_id>/ui_history', methods=['GET'])
def get_ui_history(chat_id):
削除終了：この関数ブロックまで（次の “# ツール関連のエンドポイント” コメント直前まで）

削除する関数：

get_ui_history
get_ui_history_logs
append_ui_log
handle_ui_state
clear_ui_history
置き換え（任意だが推奨）
削除した場所に、移管した旨のコメントだけ残すと追跡が楽です：

Copy# --- NOTE ---
# /api/folders, /api/chats*, /api/chats/<id>/ui_history* は ecosystem component:
#   ecosystem/default/backend/components/io_http_chats (io_http_chats_v1)
# に移管しました。

Step 6（新規）: /api/chats/<chat_id>/tools を ecosystem 側へ実装（io_http_chat_tools_v1）
新規: ecosystem/default/backend/components/io_http_chat_tools/manifest.json
Copy{
  "type": "io",
  "id": "io_http_chat_tools_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Chatごとの active_tools 設定API（/api/chats/<chat_id>/tools）を提供する"
  }
}
新規: ecosystem/default/backend/components/io_http_chat_tools/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Tuple


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_chat_tools.register",
                handler="io_http_chat_tools:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        # blueprint重複登録防止（idempotent）
        if "rumi_io_http_chat_tools_v1" in getattr(app, "blueprints", {}):
            return

        from flask import Blueprint, request, jsonify

        bp = Blueprint("rumi_io_http_chat_tools_v1", __name__)

        @bp.route("/api/chats/<chat_id>/tools", methods=["GET", "POST"])
        def handle_chat_tools(chat_id: str):
            """
            app.py の既存 handle_chat_tools と互換の挙動を提供する。
            - GET: active_tools + all_tools + mode
            - POST: active_tools を更新
            """
            # 遅延 import（移行中のため root 実装を利用）
            from chat_manager import ChatManager
            chat_manager = ChatManager()

            # ai_manager は現段階では公式app.py側のグローバルに依存しているため、
            # まずは「import app」経由で参照する（移行ブリッジ）。後で interface に置換する。
            try:
                import app as app_module  # type: ignore
                ai_manager = getattr(app_module, "ai_manager", None)
            except Exception:
                ai_manager = None

            if request.method == "GET":
                try:
                    chat_data = chat_manager.load_chat_history(chat_id)
                    active_tools = chat_data.get("active_tools")

                    all_tools = []
                    if ai_manager and getattr(ai_manager, "tool_loader", None):
                        for tool_name, tool_info in ai_manager.tool_loader.loaded_tools.items():
                            all_tools.append({
                                "name": tool_name,
                                "display_name": tool_info.get("name", tool_name),
                                "description": tool_info.get("description", ""),
                                "icon": tool_info.get("icon", "🔧"),
                                "enabled": tool_info.get("enabled", True),
                            })

                    if active_tools is None:
                        mode = "all"
                    elif isinstance(active_tools, list) and len(active_tools) == 0:
                        mode = "none"
                    else:
                        mode = "allowlist"

                    return jsonify({
                        "active_tools": active_tools,
                        "all_tools": all_tools,
                        "mode": mode
                    }), 200

                except FileNotFoundError:
                    return jsonify({"error": "Chat not found"}), 404
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            # POST
            try:
                data = request.get_json(silent=True) or {}

                if "active_tools" not in data:
                    return jsonify({"error": "active_tools field is required"}), 400

                active_tools = data["active_tools"]

                if active_tools is not None and not isinstance(active_tools, list):
                    return jsonify({"error": "active_tools must be null or an array"}), 400

                if isinstance(active_tools, list):
                    if not all(isinstance(t, str) for t in active_tools):
                        return jsonify({"error": "active_tools must contain only strings"}), 400

                    if ai_manager and getattr(ai_manager, "tool_loader", None):
                        valid_tools = set(ai_manager.tool_loader.loaded_tools.keys())
                        invalid_tools = [t for t in active_tools if t not in valid_tools]
                        if invalid_tools:
                            return jsonify({
                                "error": f"Invalid tool names: {invalid_tools}",
                                "valid_tools": list(valid_tools),
                            }), 400

                chat_manager.update_chat_metadata(chat_id, {"active_tools": active_tools})

                return jsonify({"success": True, "active_tools": active_tools}), 200

            except FileNotFoundError:
                return jsonify({"error": "Chat not found"}), 404
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        app.register_blueprint(bp)

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_chat_tools_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_chat_tools.register",
            handler="io_http_chat_tools:setup",
            status="success",
            meta={"registered": ["io.http.binders"], "routes": ["/api/chats/<chat_id>/tools"]},
        )

修正: app.py（削除指示の訂正）
A) 削除してよい（すでに io_http_chats_v1 が提供するため）
次の関数ブロックだけ削除してください（handle_chat_tools は削除しません）。

create_folder
削除対象：次の行から、その関数の終端まで
Copy@app.route('/api/folders', methods=['POST'])
def create_folder():
get_all_chats
Copy@app.route('/api/chats', methods=['GET'])
def get_all_chats():
create_new_chat
Copy@app.route('/api/chats', methods=['POST'])
def create_new_chat():
handle_single_chat
Copy@app.route('/api/chats/<chat_id>', methods=['GET', 'DELETE', 'PATCH'])
def handle_single_chat(chat_id):
copy_chat
Copy@app.route('/api/chats/<chat_id>/copy', methods=['POST'])
def copy_chat(chat_id):
UI履歴系（5つ）
get_ui_history
Copy@app.route('/api/chats/<chat_id>/ui_history', methods=['GET'])
def get_ui_history(chat_id):
get_ui_history_logs
Copy@app.route('/api/chats/<chat_id>/ui_history/logs', methods=['GET'])
def get_ui_history_logs(chat_id):
append_ui_log
Copy@app.route('/api/chats/<chat_id>/ui_history/append_log', methods=['POST'])
def append_ui_log(chat_id):
handle_ui_state
Copy@app.route('/api/chats/<chat_id>/ui_history/state', methods=['GET', 'POST'])
def handle_ui_state(chat_id):
clear_ui_history
Copy@app.route('/api/chats/<chat_id>/ui_history/clear', methods=['DELETE'])
def clear_ui_history(chat_id):
B) 削除しない（訂正）
削除しない：
Copy@app.route('/api/chats/<chat_id>/tools', methods=['GET', 'POST'])
def handle_chat_tools(chat_id):
ただし、今回追加した io_http_chat_tools_v1 が動作確認できたら、次のステップでこのブロックも 同じ方式でピンポイント削除します（その時点で初めて削除）。


修正: app.py
1) /api/folders を削除（create_folder ブロック丸ごと削除）
削除：次のブロック全体

Copy@app.route('/api/folders', methods=['POST'])
def create_folder():
    data = request.get_json() if request.is_json else {}
    folder_name = data.get('name', '').strip()
    
    try:
        folder_name = chat_manager.create_folder(folder_name)
        return jsonify({'success': True, 'folder_name': folder_name}), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': str(e)}), 500
2) /api/chats（GET/POST）を削除（get_all_chats / create_new_chat ブロック丸ごと削除）
削除：次の2ブロック全体

Copy@app.route('/api/chats', methods=['GET'])
def get_all_chats():
    return jsonify(chat_manager.get_all_chats())

@app.route('/api/chats', methods=['POST'])
def create_new_chat():
    data = request.get_json() if request.is_json else {}
    folder_name = data.get('folder', None)
    
    metadata = chat_manager.create_chat(folder_name)
    return jsonify(metadata), 201
3) /api/chats/<chat_id>（GET/DELETE/PATCH）を削除（handle_single_chat ブロック丸ごと削除）
削除：次のブロック全体

Copy@app.route('/api/chats/<chat_id>', methods=['GET', 'DELETE', 'PATCH'])
def handle_single_chat(chat_id):
    if request.method == 'DELETE':
        try:
            # チャットに関連するリレーションシップを削除
            deleted_links = relationship_manager.delete_all_links_for(chat_id)
            if deleted_links > 0:
                print(f"Deleted {deleted_links} relationship links for chat {chat_id}")
            
            chat_manager.delete_chat(chat_id)
            return jsonify({'success': True}), 200
        except FileNotFoundError:
            return jsonify({'error': 'Chat not found'}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    if request.method == 'GET':
        try:
            data = chat_manager.load_chat_history(chat_id)
            return jsonify(data)
        except FileNotFoundError:
            return jsonify({
                'metadata': {'title': '新しいチャット', 'is_pinned': False, 'folder': None},
                'messages': []
            })
    
    if request.method == 'PATCH':
        try:
            chat_manager.update_chat_metadata(chat_id, request.json)
            return jsonify({'success': True}), 200
        except Exception as e:
            return jsonify({'error': str(e)}), 500
4) 重要：/api/chats/<chat_id>/tools は 削除しない
以下のブロックは そのまま残してください（現時点では ecosystem 側へ完全移管済みでないため）：

Copy@app.route('/api/chats/<chat_id>/tools', methods=['GET', 'POST'])
def handle_chat_tools(chat_id):
    ...
5) /api/chats/<chat_id>/copy を削除（copy_chat ブロック丸ごと削除）
削除：次のブロック全体

Copy@app.route('/api/chats/<chat_id>/copy', methods=['POST'])
def copy_chat(chat_id):
    try:
        new_chat_id = chat_manager.copy_chat(chat_id)
        return jsonify({'success': True, 'new_chat_id': new_chat_id}), 201
    except FileNotFoundError:
        return jsonify({'error': 'Source chat not found'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500
6) UI履歴（/ui_history 系）を削除（5ブロック丸ごと削除）
削除：以下のブロック全体（5つ）

Copy# UI履歴関連のエンドポイント
@app.route('/api/chats/<chat_id>/ui_history', methods=['GET'])
def get_ui_history(chat_id):
    """UI履歴を取得"""
    try:
        ui_data = chat_manager.load_ui_history(chat_id)
        return jsonify(ui_data), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/chats/<chat_id>/ui_history/logs', methods=['GET'])
def get_ui_history_logs(chat_id):
    """ツールログのみを取得"""
    try:
        ui_data = chat_manager.load_ui_history(chat_id)
        
        # クエリパラメータで実行IDによるフィルタリング
        execution_id = request.args.get('execution_id')
        if execution_id:
            logs = chat_manager.get_tool_logs_for_execution(chat_id, execution_id)
        else:
            logs = ui_data.get('tool_logs', [])
        
        return jsonify({'logs': logs}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/chats/<chat_id>/ui_history/append_log', methods=['POST'])
def append_ui_log(chat_id):
    """ツールログを追加（フロントエンドから直接追加する場合用）"""
    try:
        log_entry = request.json
        message_id = chat_manager.append_tool_log(chat_id, log_entry)
        return jsonify({'success': True, 'message_id': message_id}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/chats/<chat_id>/ui_history/state', methods=['GET', 'POST'])
def handle_ui_state(chat_id):
    """UI状態を取得/更新"""
    try:
        if request.method == 'GET':
            ui_data = chat_manager.load_ui_history(chat_id)
            return jsonify({'ui_state': ui_data.get('ui_state', {})}), 200
        
        elif request.method == 'POST':
            state_updates = request.json
            for key, value in state_updates.items():
                chat_manager.update_ui_state(chat_id, key, value)
            return jsonify({'success': True}), 200
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/chats/<chat_id>/ui_history/clear', methods=['DELETE'])
def clear_ui_history(chat_id):
    """UI履歴をクリア"""
    try:
        chat_manager.clear_ui_history(chat_id)
        return jsonify({'success': True}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500
7) （推奨）削除跡に移管コメントを追加（任意・安全）
上の削除を行った付近（元の /api/folders あたり）に、コメントを1つ追加しておくと追跡が楽です：

Copy# NOTE: /api/folders, /api/chats (list/create), /api/chats/<id> (get/delete/patch),
#       /api/chats/<id>/copy, /api/chats/<id>/ui_history* は ecosystem の
#       io_http_chats_v1 へ移管しました。
#       /api/chats/<id>/tools は移行中のため app.py に残しています。


修正: ecosystem/default/backend/components/io_http_chat_tools/setup.py（既存ファイル、修正部分のみ）
1) 先頭に import を追加（os）
Copy# --- 修正箇所: ファイル先頭付近 ---
import os
2) bind_http 内で「既存ルート検出→スキップ」を追加
bind_http の冒頭（blueprint重複防止の直後）に、以下を挿入してください。

Copy# --- 修正箇所: bind_http(app, kernel, ctx) の先頭付近 ---

        # 移行中の衝突回避:
        # app.py 側に同一ルートが残っている場合は binder 側で登録しない（デフォルト）
        # 強制的にecosystem版を有効化したい場合のみ env で上書きできる
        force_enable = os.environ.get("RUMI_IO_HTTP_CHAT_TOOLS_ENABLE", "").strip().lower() in ("1", "true", "yes", "on")

        def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
            try:
                want_methods = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want_methods:
                        existing = set(m.upper() for m in (r.methods or set()))
                        # HEAD/OPTIONSは自動付与され得るので、必要メソッドが含まれるかで判定
                        if not want_methods.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                # url_map が取れない等は安全側で「存在しない」とみなす
                return False

        legacy_rule = "/api/chats/<chat_id>/tools"
        if not force_enable and _route_exists(legacy_rule, methods={"GET", "POST"}):
            # 既存（app.py）のルートがあるため、衝突を避けて binder をスキップ
            return
3) blueprint重複チェックも “ルート衝突回避の後” に置きたい（順序修正）
いまのコードが

blueprint名チェック → その後に route 定義
になっているはずですが、上の “ルート衝突回避” は blueprint登録前に行う必要があります。
したがって、bind_http 冒頭にあるこの行：

Copy        if "rumi_io_http_chat_tools_v1" in getattr(app, "blueprints", {}):
            return
は ルート衝突回避チェックの後に移動してください。

修正後の順序イメージは：

force_enable / route_exists 定義
既存ルートがあれば return
blueprint重複なら return
blueprint作成→ルート定義→register


Step 7-A（新規）: io_http_relationships_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_relationships/manifest.json
Copy{
  "type": "io",
  "id": "io_http_relationships_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Relationship API (/api/relationships*) を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_relationships/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional
import os


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_relationships.register",
                handler="io_http_relationships:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        # 既にblueprintが登録済みなら何もしない（idempotent）
        if "rumi_io_http_relationships_v1" in getattr(app, "blueprints", {}):
            return

        # 段階移行中の衝突回避:
        # app.py に同一ルートが残っている場合は binder 側で登録しない（デフォルト）
        force_enable = os.environ.get("RUMI_IO_HTTP_RELATIONSHIPS_ENABLE", "").strip().lower() in ("1", "true", "yes", "on")

        def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
            try:
                want_methods = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want_methods:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want_methods.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        legacy_rules = [
            ("/api/relationships", {"GET", "POST"}),
            ("/api/relationships/<entity_id>", {"GET", "DELETE"}),
        ]
        if not force_enable:
            for rule, methods in legacy_rules:
                if _route_exists(rule, methods=methods):
                    # legacy が残っているので衝突回避でスキップ
                    return

        from flask import Blueprint, request, jsonify
        from relationship_manager import RelationshipManager

        bp = Blueprint("rumi_io_http_relationships_v1", __name__)
        relationship_manager = RelationshipManager()

        @bp.route("/api/relationships", methods=["GET", "POST"])
        def handle_relationships():
            """リレーションシップの取得/作成（app.py互換）"""
            if request.method == "GET":
                entity_id = request.args.get("entity_id")
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")

                if entity_id:
                    links = relationship_manager.get_related(entity_id, link_type, direction)
                else:
                    links = relationship_manager.get_all_links()

                return jsonify({"links": links}), 200

            # POST
            try:
                data = request.get_json(silent=True) or {}
                required_fields = ["source", "target", "type"]
                for field in required_fields:
                    if field not in data:
                        return jsonify({"error": f"{field} is required"}), 400

                link = relationship_manager.link(
                    source=data["source"],
                    target=data["target"],
                    link_type=data["type"],
                    metadata=data.get("metadata", {}),
                )
                return jsonify({"success": True, "link": link}), 201

            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @bp.route("/api/relationships/<entity_id>", methods=["GET", "DELETE"])
        def handle_entity_relationships(entity_id: str):
            """特定エンティティのリレーションシップを取得/削除（app.py互換）"""
            if request.method == "GET":
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")

                links = relationship_manager.get_related(entity_id, link_type, direction)
                ids = relationship_manager.get_related_ids(entity_id, link_type, direction)

                return jsonify({
                    "entity_id": entity_id,
                    "links": links,
                    "related_ids": ids
                }), 200

            # DELETE
            data = request.get_json(silent=True) or {}
            target = data.get("target")
            link_type = data.get("type")

            if target and link_type:
                success = relationship_manager.unlink(entity_id, target, link_type)
                return jsonify({"success": success}), 200 if success else 404
            else:
                count = relationship_manager.delete_all_links_for(entity_id)
                return jsonify({"success": True, "deleted_count": count}), 200

        app.register_blueprint(bp)

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_relationships_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_relationships.register",
            handler="io_http_relationships:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/relationships", "/api/relationships/<entity_id>"],
                "conflict_policy": "auto-skip-if-legacy-exists (override: RUMI_IO_HTTP_RELATIONSHIPS_ENABLE=1)"
            },
        )
Step 7-B（既存修正）: app.py から relationship ルートをピンポイント削除
以下の 2ブロックを app.py から削除してください（完全一致で、他は触りません）。

修正: app.py
1) /api/relationships ブロック削除
削除：次のブロック全体

Copy@app.route('/api/relationships', methods=['GET', 'POST'])
def handle_relationships():
    """リレーションシップの取得/作成"""
    
    if request.method == 'GET':
        # クエリパラメータでフィルタリング
        entity_id = request.args.get('entity_id')
        link_type = request.args.get('type')
        direction = request.args.get('direction', 'both')
        
        if entity_id:
            links = relationship_manager.get_related(entity_id, link_type, direction)
        else:
            links = relationship_manager.get_all_links()
        
        return jsonify({'links': links}), 200
    
    elif request.method == 'POST':
        try:
            data = request.json
            
            required_fields = ['source', 'target', 'type']
            for field in required_fields:
                if field not in data:
                    return jsonify({'error': f'{field} is required'}), 400
            
            link = relationship_manager.link(
                source=data['source'],
                target=data['target'],
                link_type=data['type'],
                metadata=data.get('metadata', {})
            )
            
            return jsonify({'success': True, 'link': link}), 201
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500
2) /api/relationships/<entity_id> ブロック削除
削除：次のブロック全体

Copy@app.route('/api/relationships/<entity_id>', methods=['GET', 'DELETE'])
def handle_entity_relationships(entity_id):
    """特定エンティティのリレーションシップを取得/削除"""
    
    if request.method == 'GET':
        link_type = request.args.get('type')
        direction = request.args.get('direction', 'both')
        
        links = relationship_manager.get_related(entity_id, link_type, direction)
        ids = relationship_manager.get_related_ids(entity_id, link_type, direction)
        
        return jsonify({
            'entity_id': entity_id,
            'links': links,
            'related_ids': ids
        }), 200
    
    elif request.method == 'DELETE':
        # 特定のリンクを削除
        data = request.json or {}
        target = data.get('target')
        link_type = data.get('type')
        
        if target and link_type:
            # 特定のリンクを削除
            success = relationship_manager.unlink(entity_id, target, link_type)
            return jsonify({'success': success}), 200 if success else 404
        else:
            # エンティティに関連する全リンクを削除
            count = relationship_manager.delete_all_links_for(entity_id)
            return jsonify({'success': True, 'deleted_count': count}), 200




修正1: ecosystem/default/backend/components/io_http_chat_tools/setup.py
A) チェック順序を固定（ルート衝突チェック → blueprint重複チェック）
bind_http 冒頭の順序を以下にしてください（blueprint重複チェックが先にあるなら後ろへ移動）。

Copy# --- 修正箇所: bind_http(app, kernel, ctx) の冒頭付近（順序をこの形にする） ---

        # 移行中の衝突回避（デフォルト安全側）
        force_enable = os.environ.get("RUMI_IO_HTTP_CHAT_TOOLS_ENABLE", "").strip().lower() in ("1", "true", "yes", "on")

        def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
            try:
                want_methods = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want_methods:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want_methods.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        legacy_rule = "/api/chats/<chat_id>/tools"
        if not force_enable and _route_exists(legacy_rule, methods={"GET", "POST"}):
            # app.py 側に同一ルートが残っているため、衝突回避で登録しない
            return

        # blueprint重複登録防止（idempotent）
        if "rumi_io_http_chat_tools_v1" in getattr(app, "blueprints", {}):
            return
これで「app.py に残している間は ecosystem 側が絶対に同一ルートを登録しない」ので、binder適用順に依存したクラッシュが防げます。

修正2: app.py（HTTP binder 適用を “完了扱い” しない。段階移行に強くする）
A) グローバル変数：_kernel_http_binders_applied を使わない設計へ
（既存の Trueになったら二度と適用しない が問題の根本なので）

Copy# --- 修正箇所: app.py の Kernel HTTP binder 状態管理（該当部分を置換） ---

# 変更前:
# _kernel_http_binders_applied = False
# _kernel_http_lock = threading.Lock()
# _kernel_http_apply_error = None
# _kernel_http_last_apply_attempt = 0.0
# _kernel_http_min_attempt_interval_sec = 1.0

# 変更後:
_kernel_http_lock = threading.Lock()
_kernel_http_apply_error = None

# binder 適用は段階移行で後から成功し得るため「完了扱い」にしない。
# ただし毎リクエストで走らないようスロットリングする。
_kernel_http_last_apply_attempt = 0.0
_kernel_http_min_attempt_interval_sec = 1.0
※ もし既に _kernel_http_binders_applied がどこかで参照されている場合は、その参照も削除します（下の関数置換で解消します）。

B) ensure_http_binders_applied() を「定期的に再試行する」実装に置換
「一度でも適用できたら完了」ロジックを完全に撤去し、1秒に1回まで全 binder を呼びます（binder側が idempotent なので重複登録は起きません）。

Copy# --- 修正箇所: app.py の ensure_http_binders_applied() を丸ごと置換 ---

def ensure_http_binders_applied():
    """
    ecosystem が InterfaceRegistry に登録した io.http.binders を Flask app に適用する。

    段階移行に強い方針:
    - “一度適用できたら完了”にしない（後から追加/有効化される binder を拾うため）
    - 代わりにスロットリングして、一定間隔で再適用を試みる
    - binder 側は blueprint 重複チェック・ルート衝突チェックで idempotent にする
    """
    global _kernel_http_apply_error, _kernel_http_last_apply_attempt

    if _kernel is None:
        return

    now = time.time()
    if (now - _kernel_http_last_apply_attempt) < _kernel_http_min_attempt_interval_sec:
        return

    with _kernel_http_lock:
        now2 = time.time()
        if (now2 - _kernel_http_last_apply_attempt) < _kernel_http_min_attempt_interval_sec:
            return
        _kernel_http_last_apply_attempt = now2

        try:
            binders = _kernel.interface_registry.get("io.http.binders", strategy="all")
            if binders is None:
                binders = []
            if not isinstance(binders, list):
                binders = [binders]

            binders = [b for b in binders if callable(b)]

            if not binders:
                _kernel_http_apply_error = "no io.http.binders registered yet"
                return

            applied_attempted = 0
            for b in binders:
                try:
                    # binder が自分で “既に登録済みなら何もしない” を担保する
                    b(app, _kernel, {"app": app})
                    applied_attempted += 1
                except Exception as e:
                    print(f"[Kernel][io.http] binder failed (fail-soft): {e}")
                    traceback.print_exc()

            _kernel_http_apply_error = None
            # NOTE: applied_attempted は「呼んだ数」。実際に登録されたかは binder の責務。
            # 重要なのは「後から成功し得る binder を、完了扱いで殺さない」こと。
        except Exception as e:
            _kernel_http_apply_error = str(e)
            print(f"[Kernel][io.http] apply failed (fail-soft): {e}")
            traceback.print_exc()

Step 8-A（新規）: io_http_user_settings_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_user_settings/manifest.json
Copy{
  "type": "io",
  "id": "io_http_user_settings_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "User settings API (/api/user/settings) を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_user_settings/setup.py
Copyfrom __future__ import annotations

from typing import Dict, Optional
import os


def run(context: Dict) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_user_settings.register",
                handler="io_http_user_settings:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict] = None) -> None:
        # blueprint重複登録防止（idempotent）
        if "rumi_io_http_user_settings_v1" in getattr(app, "blueprints", {}):
            return

        # 段階移行中の衝突回避（デフォルト安全側）
        force_enable = os.environ.get("RUMI_IO_HTTP_USER_SETTINGS_ENABLE", "").strip().lower() in ("1", "true", "yes", "on")

        def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
            try:
                want_methods = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want_methods:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want_methods.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        legacy_rule = "/api/user/settings"
        if not force_enable and _route_exists(legacy_rule, methods={"GET", "POST"}):
            # app.py 側に同一ルートが残っているため、衝突回避で登録しない
            return

        from flask import Blueprint, request, jsonify
        from settings_manager import SettingsManager

        bp = Blueprint("rumi_io_http_user_settings_v1", __name__)
        settings_manager = SettingsManager()

        @bp.route("/api/user/settings", methods=["GET", "POST"])
        def user_settings_api():
            if request.method == "GET":
                return jsonify(settings_manager.get_user_settings())

            # POST
            data = request.get_json(silent=True)
            if not isinstance(data, dict):
                data = {}
            settings_manager.save_user_settings(data)
            return jsonify({"success": True}), 200

        app.register_blueprint(bp)

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_user_settings_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_user_settings.register",
            handler="io_http_user_settings:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/user/settings"],
                "conflict_policy": "auto-skip-if-legacy-exists (override: RUMI_IO_HTTP_USER_SETTINGS_ENABLE=1)"
            },
        )
Step 8-B（既存修正）: app.py から /api/user/settings ルートをピンポイント削除
以下の ブロック全体を削除してください（他は触りません）。

修正: app.py
削除対象: /api/user/settings（GET/POST）
削除：次のブロック全体

Copy@app.route('/api/user/settings', methods=['GET', 'POST'])
def user_settings_api():
    if request.method == 'GET':
        return jsonify(settings_manager.get_user_settings())
    elif request.method == 'POST':
        settings_manager.save_user_settings(request.json)
        return jsonify({'success': True}), 200


Step 9-A（新規）: io_http_prompts_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_prompts/manifest.json
Copy{
  "type": "io",
  "id": "io_http_prompts_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Prompts API (/api/prompts*) を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_prompts/setup.py
Copyfrom __future__ import annotations

from typing import Dict, Optional, Any, Set


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_prompts.register",
                handler="io_http_prompts:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        # blueprint重複登録防止（idempotent）
        if "rumi_io_http_prompts_v1" in getattr(app, "blueprints", {}):
            return

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want_methods = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want_methods:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want_methods.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        # ルート単位で「存在しないものだけ」登録する（段階移行に強い）
        needed = [
            ("/api/prompts", {"GET"}),
            ("/api/prompts/<prompt_id>", {"GET"}),
            ("/api/prompts/<prompt_id>/settings", {"GET", "POST"}),
            ("/api/prompts/reload", {"POST"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return  # 全部あるなら何もしない

        from flask import Blueprint, request, jsonify

        bp = Blueprint("rumi_io_http_prompts_v1", __name__)

        # PromptLoader を lazy 初期化（失敗時は SettingsManager fallback）
        state: Dict[str, Any] = {"prompt_loader": None, "init_attempted": False, "init_error": None}

        def _get_prompt_loader():
            if state["prompt_loader"] is not None:
                return state["prompt_loader"]
            if state["init_attempted"]:
                return None

            state["init_attempted"] = True
            try:
                from prompt_loader import PromptLoader  # legacy root module (移行中)
                pl = PromptLoader()
                pl.load_all_prompts()
                state["prompt_loader"] = pl
                return pl
            except Exception as e:
                state["init_error"] = f"{type(e).__name__}: {e}"
                return None

        def _settings_fallback_available_prompts():
            try:
                from settings_manager import SettingsManager
                sm = SettingsManager()
                return sm.get_available_prompts()
            except Exception:
                return []

        # 1) GET /api/prompts
        if any(rule == "/api/prompts" for rule, _ in missing):
            @bp.get("/api/prompts")
            def get_prompts():
                pl = _get_prompt_loader()
                if pl:
                    return jsonify(pl.get_available_prompts())
                # fallback
                return jsonify(_settings_fallback_available_prompts())

        # 2) GET /api/prompts/<prompt_id>
        if any(rule == "/api/prompts/<prompt_id>" for rule, _ in missing):
            @bp.get("/api/prompts/<prompt_id>")
            def get_prompt_detail(prompt_id: str):
                pl = _get_prompt_loader()
                if not pl:
                    return jsonify({"error": "Prompt loader not initialized", "details": state.get("init_error")}), 500

                if prompt_id in pl.loaded_prompts:
                    info = pl.loaded_prompts[prompt_id]
                    return jsonify({
                        "id": prompt_id,
                        "name": info["name"],
                        "description": info.get("description", ""),
                        "has_venv": info.get("has_venv", False),
                        "settings_schema": info.get("settings_schema"),
                    })
                return jsonify({"error": "Prompt not found"}), 404

        # 3) GET/POST /api/prompts/<prompt_id>/settings
        if any(rule == "/api/prompts/<prompt_id>/settings" for rule, _ in missing):
            @bp.route("/api/prompts/<prompt_id>/settings", methods=["GET", "POST"])
            def handle_prompt_settings(prompt_id: str):
                pl = _get_prompt_loader()
                if not pl:
                    return jsonify({"error": "Prompt loader not initialized", "details": state.get("init_error")}), 500

                if request.method == "GET":
                    settings = pl.get_prompt_settings(prompt_id)
                    return jsonify(settings)

                # POST
                data = request.get_json(silent=True)
                if not isinstance(data, dict):
                    data = {}
                success = pl.update_prompt_settings(prompt_id, data)
                if success:
                    return jsonify({"success": True})
                return jsonify({"error": "Failed to update settings"}), 500

        # 4) POST /api/prompts/reload
        if any(rule == "/api/prompts/reload" for rule, _ in missing):
            @bp.post("/api/prompts/reload")
            def reload_prompts():
                pl = _get_prompt_loader()
                if not pl:
                    return jsonify({"error": "Prompt loader not initialized", "details": state.get("init_error")}), 500
                result = pl.reload_all_prompts()
                return jsonify(result)

        app.register_blueprint(bp)

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_prompts_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_prompts.register",
            handler="io_http_prompts:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/prompts", "/api/prompts/<prompt_id>", "/api/prompts/<prompt_id>/settings", "/api/prompts/reload"],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 9-B（既存修正）: app.py から /api/prompts* をピンポイント削除
以下の 4ブロックを app.py から削除してください（完全一致で、他は触りません）。

修正: app.py
1) /api/prompts（GET）
削除：次のブロック全体

Copy@app.route('/api/prompts', methods=['GET'])
def get_prompts():
    """利用可能なプロンプトの一覧を取得"""
    if prompt_loader:
        return jsonify(prompt_loader.get_available_prompts())
    else:
        # フォールバック: settings_managerを使用（後方互換性）
        return jsonify(settings_manager.get_available_prompts())
2) /api/prompts/<prompt_id>（GET）
削除：次のブロック全体

Copy@app.route('/api/prompts/<prompt_id>', methods=['GET'])
def get_prompt_detail(prompt_id):
    """特定のプロンプトの詳細を取得"""
    if not prompt_loader:
        return jsonify({'error': 'Prompt loader not initialized'}), 500
    
    if prompt_id in prompt_loader.loaded_prompts:
        info = prompt_loader.loaded_prompts[prompt_id]
        return jsonify({
            'id': prompt_id,
            'name': info['name'],
            'description': info.get('description', ''),
            'has_venv': info.get('has_venv', False),
            'settings_schema': info.get('settings_schema')
        })
    return jsonify({'error': 'Prompt not found'}), 404
3) /api/prompts/<prompt_id>/settings（GET/POST）
削除：次のブロック全体

Copy@app.route('/api/prompts/<prompt_id>/settings', methods=['GET', 'POST'])
def handle_prompt_settings(prompt_id):
    """プロンプトの設定を取得/更新"""
    if not prompt_loader:
        return jsonify({'error': 'Prompt loader not initialized'}), 500
    
    if request.method == 'GET':
        settings = prompt_loader.get_prompt_settings(prompt_id)
        return jsonify(settings)
    
    elif request.method == 'POST':
        success = prompt_loader.update_prompt_settings(prompt_id, request.json)
        if success:
            return jsonify({'success': True})
        return jsonify({'error': 'Failed to update settings'}), 500
4) /api/prompts/reload（POST）
削除：次のブロック全体

Copy@app.route('/api/prompts/reload', methods=['POST'])
def reload_prompts():
    """プロンプトを再読み込み"""
    if not prompt_loader:
        return jsonify({'error': 'Prompt loader not initialized'}), 500
    
    result = prompt_loader.reload_all_prompts()
    return jsonify(result)




修正: ecosystem/default/backend/components/io_http_prompts/setup.py（修正部分のみ）
bind_http 関数を置き換え（Blueprintガード/登録を廃止し、add_url_rule方式へ）
Copy# --- 修正箇所: io_http_prompts/setup.py の bind_http をこの内容に置換 ---

def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
    def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
        try:
            want_methods = set(m.upper() for m in (methods or set()))
            for r in app.url_map.iter_rules():
                if str(r.rule) != rule:
                    continue
                if want_methods:
                    existing = set(m.upper() for m in (r.methods or set()))
                    # HEAD/OPTIONSは自動付与され得るので、必要メソッドが含まれるかで判定
                    if not want_methods.issubset(existing):
                        continue
                return True
            return False
        except Exception:
            return False

    # ルート単位で「存在しないものだけ」登録する（段階移行に強い）
    needed = [
        ("/api/prompts", {"GET"}),
        ("/api/prompts/<prompt_id>", {"GET"}),
        ("/api/prompts/<prompt_id>/settings", {"GET", "POST"}),
        ("/api/prompts/reload", {"POST"}),
    ]
    missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
    if not missing:
        return  # 全部あるなら何もしない

    # PromptLoader を lazy 初期化（失敗時は SettingsManager fallback）
    state: Dict[str, Any] = {"prompt_loader": None, "init_attempted": False, "init_error": None}

    def _get_prompt_loader():
        if state["prompt_loader"] is not None:
            return state["prompt_loader"]
        if state["init_attempted"]:
            return None

        state["init_attempted"] = True
        try:
            from prompt_loader import PromptLoader  # legacy root module (移行中)
            pl = PromptLoader()
            pl.load_all_prompts()
            state["prompt_loader"] = pl
            return pl
        except Exception as e:
            state["init_error"] = f"{type(e).__name__}: {e}"
            return None

    def _settings_fallback_available_prompts():
        try:
            from settings_manager import SettingsManager
            sm = SettingsManager()
            return sm.get_available_prompts()
        except Exception:
            return []

    from flask import request, jsonify

    # 1) GET /api/prompts
    if any(rule == "/api/prompts" for rule, _ in missing):
        def _get_prompts():
            pl = _get_prompt_loader()
            if pl:
                return jsonify(pl.get_available_prompts())
            return jsonify(_settings_fallback_available_prompts())

        app.add_url_rule(
            "/api/prompts",
            endpoint="rumi_io_http_prompts_v1.get_prompts",
            view_func=_get_prompts,
            methods=["GET"],
        )

    # 2) GET /api/prompts/<prompt_id>
    if any(rule == "/api/prompts/<prompt_id>" for rule, _ in missing):
        def _get_prompt_detail(prompt_id: str):
            pl = _get_prompt_loader()
            if not pl:
                return jsonify({"error": "Prompt loader not initialized", "details": state.get("init_error")}), 500

            if prompt_id in pl.loaded_prompts:
                info = pl.loaded_prompts[prompt_id]
                return jsonify({
                    "id": prompt_id,
                    "name": info["name"],
                    "description": info.get("description", ""),
                    "has_venv": info.get("has_venv", False),
                    "settings_schema": info.get("settings_schema"),
                })
            return jsonify({"error": "Prompt not found"}), 404

        app.add_url_rule(
            "/api/prompts/<prompt_id>",
            endpoint="rumi_io_http_prompts_v1.get_prompt_detail",
            view_func=_get_prompt_detail,
            methods=["GET"],
        )

    # 3) GET/POST /api/prompts/<prompt_id>/settings
    if any(rule == "/api/prompts/<prompt_id>/settings" for rule, _ in missing):
        def _handle_prompt_settings(prompt_id: str):
            pl = _get_prompt_loader()
            if not pl:
                return jsonify({"error": "Prompt loader not initialized", "details": state.get("init_error")}), 500

            if request.method == "GET":
                settings = pl.get_prompt_settings(prompt_id)
                return jsonify(settings)

            data = request.get_json(silent=True)
            if not isinstance(data, dict):
                data = {}
            success = pl.update_prompt_settings(prompt_id, data)
            if success:
                return jsonify({"success": True})
            return jsonify({"error": "Failed to update settings"}), 500

        app.add_url_rule(
            "/api/prompts/<prompt_id>/settings",
            endpoint="rumi_io_http_prompts_v1.handle_prompt_settings",
            view_func=_handle_prompt_settings,
            methods=["GET", "POST"],
        )

    # 4) POST /api/prompts/reload
    if any(rule == "/api/prompts/reload" for rule, _ in missing):
        def _reload_prompts():
            pl = _get_prompt_loader()
            if not pl:
                return jsonify({"error": "Prompt loader not initialized", "details": state.get("init_error")}), 500
            result = pl.reload_all_prompts()
            return jsonify(result)

        app.add_url_rule(
            "/api/prompts/reload",
            endpoint="rumi_io_http_prompts_v1.reload_prompts",
            view_func=_reload_prompts,
            methods=["POST"],
        )


修正: app.py
1) before_serving で Kernel + binder を1回適用（import時に起動しない／初回リクエストの404を防ぐ）
@app.before_request より前でも後でも良いですが、分かりやすく before_request の近くに追加してください。

Copy# --- 追加箇所: app.py（@app.before_request の直前あたり推奨） ---

@app.before_serving
def _ensure_kernel_before_serving():
    """
    重要:
    Flaskはリクエスト毎の before_request より先に URL マッチングが走るため、
    ecosystem binder が追加するルートは before_request だけでは間に合わず 404 になり得る。
    そのため「サーバがリクエストを受け付ける前」に一度だけ Kernel 起動と binder 適用を行う。
    """
    ensure_kernel_started()
    ensure_http_binders_applied()
これで /api/message など「app.py に存在しないが ecosystem が生やすルート」も最初から到達可能になります。

2) /api/chats/<chat_id>/tools を app.py から削除（完全移管）
削除：次のブロック全体（これだけをピンポイントで削除）

Copy@app.route('/api/chats/<chat_id>/tools', methods=['GET', 'POST'])
def handle_chat_tools(chat_id):
    """チャットごとのツール設定を取得/更新"""
    
    if request.method == 'GET':
        try:
            # チャット履歴を読み込んで active_tools を取得
            chat_data = chat_manager.load_chat_history(chat_id)
            active_tools = chat_data.get('active_tools')
            
            # 全ツール一覧を取得
            all_tools = []
            if ai_manager and ai_manager.tool_loader:
                for tool_name, tool_info in ai_manager.tool_loader.loaded_tools.items():
                    all_tools.append({
                        'name': tool_name,
                        'display_name': tool_info.get('name', tool_name),
                        'description': tool_info.get('description', ''),
                        'icon': tool_info.get('icon', '🔧'),
                        'enabled': tool_info.get('enabled', True)
                    })
            
            # モードを判定
            if active_tools is None:
                mode = "all"  # 全ツール許可
            elif len(active_tools) == 0:
                mode = "none"  # 全ツール禁止
            else:
                mode = "allowlist"  # 許可リスト
            
            return jsonify({
                'active_tools': active_tools,
                'all_tools': all_tools,
                'mode': mode
            }), 200
            
        except FileNotFoundError:
            return jsonify({'error': 'Chat not found'}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    elif request.method == 'POST':
        try:
            data = request.json
            
            if 'active_tools' not in data:
                return jsonify({'error': 'active_tools field is required'}), 400
            
            active_tools = data['active_tools']
            
            # バリデーション
            if active_tools is not None and not isinstance(active_tools, list):
                return jsonify({'error': 'active_tools must be null or an array'}), 400
            
            if isinstance(active_tools, list):
                # リスト内の要素が全て文字列かチェック
                if not all(isinstance(t, str) for t in active_tools):
                    return jsonify({'error': 'active_tools must contain only strings'}), 400
                
                # 存在するツール名かチェック（オプション）
                if ai_manager and ai_manager.tool_loader:
                    valid_tools = set(ai_manager.tool_loader.loaded_tools.keys())
                    invalid_tools = [t for t in active_tools if t not in valid_tools]
                    if invalid_tools:
                        return jsonify({
                            'error': f'Invalid tool names: {invalid_tools}',
                            'valid_tools': list(valid_tools)
                        }), 400
            
            # メタデータを更新
            chat_manager.update_chat_metadata(chat_id, {'active_tools': active_tools})
            
            return jsonify({
                'success': True,
                'active_tools': active_tools
            }), 200
            
        except FileNotFoundError:
            return jsonify({'error': 'Chat not found'}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500
これで /api/chats/<chat_id>/tools は ecosystem の io_http_chat_tools_v1 側のみが提供する状態になり、重複登録のクラッシュが消えます。
また before_serving により、最初のアクセスから ecosystem ルートが存在します。


修正: app.py
1) before_serving 依存をやめる（あれば削除）
もし Step10 で追加した以下のブロックがあるなら、削除してください（正しさの前提にしません）。

Copy@app.before_serving
def _ensure_kernel_before_serving():
    ensure_kernel_started()
    ensure_http_binders_applied()
2) WSGIミドルウェアを追加（初回リクエストでも確実に binder を適用）
ensure_http_binders_applied() 関数定義の直後あたりに、以下を追加してください。

Copy# --- 追加箇所: app.py（ensure_http_binders_applied 定義の後） ---

class _LazyKernelAndBinderWSGIMiddleware:
    """
    Flaskのルーティングより前（WSGI入口）で一度だけ Kernel 起動と binder 適用を行う。
    - import時に重い処理を走らせない（lazy）
    - before_request では遅すぎて 404 になり得る問題を回避
    - 段階移行で binder が後から有効になる場合も、ensure_http_binders_applied が再試行する
    """
    def __init__(self, wsgi_app):
        self._wsgi_app = wsgi_app
        self._init_lock = threading.Lock()
        self._initialized = False

    def __call__(self, environ, start_response):
        # ルーティング前に一度だけ初期化（fail-soft）
        if not self._initialized:
            with self._init_lock:
                if not self._initialized:
                    try:
                        ensure_kernel_started()
                        ensure_http_binders_applied()
                    except Exception as e:
                        print(f"[WSGI] lazy kernel/binder init failed (fail-soft): {e}")
                        traceback.print_exc()
                    finally:
                        self._initialized = True

        # 段階移行で後から binder が追加/有効化されるケースに備え、以後もスロットリング付きで再試行
        try:
            ensure_http_binders_applied()
        except Exception:
            pass

        return self._wsgi_app(environ, start_response)


# 重要: ルーティング前に走るよう wsgi_app をラップする（多重ラップ防止）
if not isinstance(app.wsgi_app, _LazyKernelAndBinderWSGIMiddleware):
    app.wsgi_app = _LazyKernelAndBinderWSGIMiddleware(app.wsgi_app)


Step 11-A（新規）: io_http_supporters_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_supporters/manifest.json
Copy{
  "type": "io",
  "id": "io_http_supporters_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Supporters API (/api/supporters* と /api/chats/<id>/supporters) を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_supporters/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set


# module-level cache (binder再実行でも保持される)
_STATE: Dict[str, Any] = {
    "supporter_loader": None,
    "supporter_loader_init_attempted": False,
    "supporter_loader_init_error": None,
    "dependency_manager": None,
    "dependency_manager_init_attempted": False,
    "dependency_manager_init_error": None,
}


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_supporters.register",
                handler="io_http_supporters:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want_methods = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want_methods:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want_methods.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        needed = [
            ("/api/supporters", {"GET"}),
            ("/api/supporters/reload", {"POST"}),
            ("/api/supporters/<supporter_name>/settings", {"GET", "POST"}),
            ("/api/supporters/<supporter_name>/venv-status", {"GET"}),
            ("/api/supporters/<supporter_name>/install-deps", {"POST"}),
            ("/api/chats/<chat_id>/supporters", {"GET", "POST"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return

        from flask import request, jsonify

        def _get_supporter_loader():
            if _STATE["supporter_loader"] is not None:
                return _STATE["supporter_loader"]
            if _STATE["supporter_loader_init_attempted"]:
                return None

            _STATE["supporter_loader_init_attempted"] = True
            # 優先: 直接 import（本来はecosystem側の責務に寄せる）
            try:
                from supporter.supporter_loader import SupporterLoader  # legacy import path
                sl = SupporterLoader()
                sl.load_all_supporters()
                _STATE["supporter_loader"] = sl
                return sl
            except Exception as e:
                _STATE["supporter_loader_init_error"] = f"{type(e).__name__}: {e}"

            # フォールバック: app.py のグローバル（移行中の暫定）
            try:
                import app as app_module  # type: ignore
                sl = getattr(app_module, "supporter_loader", None)
                if sl is not None:
                    _STATE["supporter_loader"] = sl
                    return sl
            except Exception:
                pass

            return None

        def _get_dependency_manager():
            if _STATE["dependency_manager"] is not None:
                return _STATE["dependency_manager"]
            if _STATE["dependency_manager_init_attempted"]:
                return None

            _STATE["dependency_manager_init_attempted"] = True

            # フォールバック: app.py のグローバル（移行中の暫定）
            try:
                import app as app_module  # type: ignore
                dm = getattr(app_module, "supporter_dependency_manager", None)
                if dm is not None:
                    _STATE["dependency_manager"] = dm
                    return dm
            except Exception:
                pass

            _STATE["dependency_manager_init_error"] = "Dependency manager not available"
            return None

        # 依存の少ないChatManagerは直接 import
        def _get_chat_manager():
            from chat_manager import ChatManager
            return ChatManager()

        # -------------------------
        # /api/supporters (GET)
        # -------------------------
        if any(rule == "/api/supporters" for rule, _ in missing):
            def _get_all_supporters():
                sl = _get_supporter_loader()
                if not sl:
                    return jsonify({"error": "Supporter loader not initialized", "details": _STATE.get("supporter_loader_init_error")}), 500

                supporters = sl.get_all_supporters_info()
                return jsonify({"success": True, "supporters": supporters, "count": len(supporters)})

            app.add_url_rule(
                "/api/supporters",
                endpoint="rumi_io_http_supporters_v1.get_all_supporters",
                view_func=_get_all_supporters,
                methods=["GET"],
            )

        # -------------------------
        # /api/supporters/reload (POST)
        # -------------------------
        if any(rule == "/api/supporters/reload" for rule, _ in missing):
            def _reload_supporters():
                sl = _get_supporter_loader()
                if not sl:
                    return jsonify({"error": "Supporter loader not initialized", "details": _STATE.get("supporter_loader_init_error")}), 500
                result = sl.reload_all_supporters()
                return jsonify(result)

            app.add_url_rule(
                "/api/supporters/reload",
                endpoint="rumi_io_http_supporters_v1.reload_supporters",
                view_func=_reload_supporters,
                methods=["POST"],
            )

        # -------------------------
        # /api/supporters/<name>/settings (GET/POST)
        # -------------------------
        if any(rule == "/api/supporters/<supporter_name>/settings" for rule, _ in missing):
            def _handle_supporter_settings(supporter_name: str):
                sl = _get_supporter_loader()
                if not sl:
                    return jsonify({"error": "Supporter loader not initialized", "details": _STATE.get("supporter_loader_init_error")}), 500

                if request.method == "GET":
                    settings = sl.get_supporter_settings(supporter_name)
                    return jsonify(settings)

                data = request.get_json(silent=True)
                if not isinstance(data, dict):
                    data = {}
                success = sl.update_supporter_settings(supporter_name, data)
                if success:
                    return jsonify({"success": True})
                return jsonify({"error": "Failed to update settings"}), 500

            app.add_url_rule(
                "/api/supporters/<supporter_name>/settings",
                endpoint="rumi_io_http_supporters_v1.handle_supporter_settings",
                view_func=_handle_supporter_settings,
                methods=["GET", "POST"],
            )

        # -------------------------
        # /api/supporters/<name>/venv-status (GET)
        # -------------------------
        if any(rule == "/api/supporters/<supporter_name>/venv-status" for rule, _ in missing):
            def _get_supporter_venv_status(supporter_name: str):
                dm = _get_dependency_manager()
                if not dm:
                    return jsonify({"error": "Dependency manager not initialized", "details": _STATE.get("dependency_manager_init_error")}), 500
                status = dm.get_venv_status(supporter_name)
                return jsonify(status)

            app.add_url_rule(
                "/api/supporters/<supporter_name>/venv-status",
                endpoint="rumi_io_http_supporters_v1.get_supporter_venv_status",
                view_func=_get_supporter_venv_status,
                methods=["GET"],
            )

        # -------------------------
        # /api/supporters/<name>/install-deps (POST)
        # -------------------------
        if any(rule == "/api/supporters/<supporter_name>/install-deps" for rule, _ in missing):
            def _install_supporter_dependencies(supporter_name: str):
                dm = _get_dependency_manager()
                if not dm:
                    return jsonify({"error": "Dependency manager not initialized", "details": _STATE.get("dependency_manager_init_error")}), 500
                result = dm.install_requirements(supporter_name)
                return jsonify(result)

            app.add_url_rule(
                "/api/supporters/<supporter_name>/install-deps",
                endpoint="rumi_io_http_supporters_v1.install_supporter_dependencies",
                view_func=_install_supporter_dependencies,
                methods=["POST"],
            )

        # -------------------------
        # /api/chats/<chat_id>/supporters (GET/POST)
        # -------------------------
        if any(rule == "/api/chats/<chat_id>/supporters" for rule, _ in missing):
            def _handle_chat_supporters(chat_id: str):
                chat_manager = _get_chat_manager()
                sl = _get_supporter_loader()

                if request.method == "GET":
                    try:
                        chat_data = chat_manager.load_chat_history(chat_id)
                        active_supporters = chat_data.get("active_supporters", [])
                        all_supporters = sl.get_all_supporters_info() if sl else []
                        return jsonify({
                            "active_supporters": active_supporters,
                            "all_supporters": all_supporters
                        }), 200
                    except FileNotFoundError:
                        return jsonify({"error": "Chat not found"}), 404
                    except Exception as e:
                        return jsonify({"error": str(e)}), 500

                # POST
                try:
                    data = request.get_json(silent=True) or {}
                    if "supporters" not in data:
                        return jsonify({"error": "supporters field is required"}), 400

                    supporters_list = data["supporters"]

                    if not isinstance(supporters_list, list):
                        return jsonify({"error": "supporters must be an array"}), 400
                    if not all(isinstance(s, str) for s in supporters_list):
                        return jsonify({"error": "supporters must contain only strings"}), 400

                    if sl:
                        valid_supporters = set(sl.loaded_supporters.keys())
                        invalid_supporters = [s for s in supporters_list if s not in valid_supporters]
                        if invalid_supporters:
                            return jsonify({
                                "error": f"Invalid supporter names: {invalid_supporters}",
                                "valid_supporters": list(valid_supporters)
                            }), 400

                    chat_manager.update_chat_metadata(chat_id, {"active_supporters": supporters_list})
                    return jsonify({"success": True, "active_supporters": supporters_list}), 200

                except FileNotFoundError:
                    return jsonify({"error": "Chat not found"}), 404
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/chats/<chat_id>/supporters",
                endpoint="rumi_io_http_supporters_v1.handle_chat_supporters",
                view_func=_handle_chat_supporters,
                methods=["GET", "POST"],
            )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_supporters_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_supporters.register",
            handler="io_http_supporters:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": [
                    "/api/supporters",
                    "/api/supporters/reload",
                    "/api/supporters/<supporter_name>/settings",
                    "/api/supporters/<supporter_name>/venv-status",
                    "/api/supporters/<supporter_name>/install-deps",
                    "/api/chats/<chat_id>/supporters"
                ],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 11-B（既存修正）: app.py から supporters ルートをピンポイント削除
以下の 6ブロックを app.py から削除してください（完全一致で、他は触りません）。

修正: app.py
1) get_all_supporters
削除（ブロック全体）：

Copy@app.route('/api/supporters', methods=['GET'])
def get_all_supporters():
    """利用可能なすべてのサポーターを取得"""
    if not supporter_loader:
        return jsonify({'error': 'Supporter loader not initialized'}), 500
    
    supporters = supporter_loader.get_all_supporters_info()
    return jsonify({
        'success': True,
        'supporters': supporters,
        'count': len(supporters)
    })
2) reload_supporters
削除：

Copy@app.route('/api/supporters/reload', methods=['POST'])
def reload_supporters():
    """サポーターを再読み込み"""
    if not supporter_loader:
        return jsonify({'error': 'Supporter loader not initialized'}), 500
    
    result = supporter_loader.reload_all_supporters()
    return jsonify(result)
3) handle_supporter_settings
削除：

Copy@app.route('/api/supporters/<supporter_name>/settings', methods=['GET', 'POST'])
def handle_supporter_settings(supporter_name):
    """サポーターの設定を取得/更新"""
    if not supporter_loader:
        return jsonify({'error': 'Supporter loader not initialized'}), 500
    
    if request.method == 'GET':
        settings = supporter_loader.get_supporter_settings(supporter_name)
        return jsonify(settings)
    
    elif request.method == 'POST':
        success = supporter_loader.update_supporter_settings(supporter_name, request.json)
        if success:
            return jsonify({'success': True})
        return jsonify({'error': 'Failed to update settings'}), 500
4) get_supporter_venv_status
削除：

Copy@app.route('/api/supporters/<supporter_name>/venv-status', methods=['GET'])
def get_supporter_venv_status(supporter_name):
    """サポーターの仮想環境ステータスを取得"""
    if not supporter_dependency_manager:
        return jsonify({'error': 'Dependency manager not initialized'}), 500
    
    status = supporter_dependency_manager.get_venv_status(supporter_name)
    return jsonify(status)
5) install_supporter_dependencies
削除：

Copy@app.route('/api/supporters/<supporter_name>/install-deps', methods=['POST'])
def install_supporter_dependencies(supporter_name):
    """サポーターの依存関係をインストール"""
    if not supporter_dependency_manager:
        return jsonify({'error': 'Dependency manager not initialized'}), 500
    
    result = supporter_dependency_manager.install_requirements(supporter_name)
    return jsonify(result)
6) handle_chat_supporters
削除：

Copy@app.route('/api/chats/<chat_id>/supporters', methods=['GET', 'POST'])
def handle_chat_supporters(chat_id):
    """チャットごとのサポーター設定を取得/更新"""
    
    if request.method == 'GET':
        try:
            # チャット履歴を読み込んで active_supporters を取得
            chat_data = chat_manager.load_chat_history(chat_id)
            active_supporters = chat_data.get('active_supporters', [])
            
            # 全サポーター一覧を取得
            all_supporters = []
            if supporter_loader:
                all_supporters = supporter_loader.get_all_supporters_info()
            
            return jsonify({
                'active_supporters': active_supporters,
                'all_supporters': all_supporters
            }), 200
            
        except FileNotFoundError:
            return jsonify({'error': 'Chat not found'}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    elif request.method == 'POST':
        try:
            data = request.json
            
            if 'supporters' not in data:
                return jsonify({'error': 'supporters field is required'}), 400
            
            supporters_list = data['supporters']
            
            # バリデーション
            if not isinstance(supporters_list, list):
                return jsonify({'error': 'supporters must be an array'}), 400
            
            if not all(isinstance(s, str) for s in supporters_list):
                return jsonify({'error': 'supporters must contain only strings'}), 400
            
            # 存在するサポーター名かチェック（オプション）
            if supporter_loader:
                valid_supporters = set(supporter_loader.loaded_supporters.keys())
                invalid_supporters = [s for s in supporters_list if s not in valid_supporters]
                if invalid_supporters:
                    return jsonify({
                        'error': f'Invalid supporter names: {invalid_supporters}',
                        'valid_supporters': list(valid_supporters)
                    }), 400
            
            # メタデータを更新
            chat_manager.update_chat_metadata(chat_id, {'active_supporters': supporters_list})
            
            return jsonify({
                'success': True,
                'active_supporters': supporters_list
            }), 200
            
        except FileNotFoundError:
            return jsonify({'error': 'Chat not found'}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500

1) Blueprint一回登録問題（段階移行に弱い）を全 io_http* で根絶：Blueprint廃止→add_url_rule化
修正: ecosystem/default/backend/components/io_http/setup.py
bind_http を Blueprint方式から add_url_rule方式に置換してください（blueprintsガード含め不要）。

Copy# --- 修正箇所: ecosystem/default/backend/components/io_http/setup.py ---
# bind_http 関数を丸ごと置換

def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
    from flask import request, jsonify

    def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
        try:
            want = set(m.upper() for m in (methods or set()))
            for r in app.url_map.iter_rules():
                if str(r.rule) != rule:
                    continue
                if want:
                    existing = set(m.upper() for m in (r.methods or set()))
                    if not want.issubset(existing):
                        continue
                return True
            return False
        except Exception:
            return False

    # /api/diagnostics
    if not _route_exists("/api/diagnostics", {"GET"}):
        def _diagnostics_endpoint():
            try:
                return jsonify(kernel.diagnostics.as_dict())
            except Exception as e:
                return jsonify({"success": False, "error": str(e)}), 500

        app.add_url_rule(
            "/api/diagnostics",
            endpoint="rumi_io_http_v1.diagnostics",
            view_func=_diagnostics_endpoint,
            methods=["GET"],
        )

    # /api/message
    if not _route_exists("/api/message", {"POST"}):
        def _message_endpoint():
            payload = request.get_json(silent=True) or {}
            chat_id = payload.get("chat_id") or request.args.get("chat_id")
            if not isinstance(chat_id, str) or not chat_id:
                return jsonify({"success": False, "error": "missing chat_id"}), 400
            try:
                result = kernel.run_message(chat_id, payload)
                return jsonify(result), 200 if result.get("success", True) else 400
            except Exception as e:
                return jsonify({"success": False, "error": str(e), "chat_id": chat_id}), 500

        app.add_url_rule(
            "/api/message",
            endpoint="rumi_io_http_v1.message",
            view_func=_message_endpoint,
            methods=["POST"],
        )

    # /api/message/stream
    if not _route_exists("/api/message/stream", {"POST"}):
        def _message_stream_endpoint():
            payload = request.get_json(silent=True) or {}
            chat_id = payload.get("chat_id") or request.args.get("chat_id")
            if not isinstance(chat_id, str) or not chat_id:
                return jsonify({"success": False, "error": "missing chat_id"}), 400
            try:
                payload2 = dict(payload)
                payload2["streaming"] = True
                out = kernel.run_message_stream(chat_id, payload2)
                return out
            except Exception as e:
                return jsonify({"success": False, "error": str(e), "chat_id": chat_id}), 500

        app.add_url_rule(
            "/api/message/stream",
            endpoint="rumi_io_http_v1.message_stream",
            view_func=_message_stream_endpoint,
            methods=["POST"],
        )
修正: ecosystem/default/backend/components/io_http_chats/setup.py
Blueprint方式をやめ、不足ルートだけ add_url_rule で追加する方式にします（順不同・部分削除に強い）。

Copy# --- 修正箇所: ecosystem/default/backend/components/io_http_chats/setup.py ---
# bind_http 関数を丸ごと置換（_lazy_get_managers はそのまま使えます）

def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
    from flask import request, jsonify

    def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
        try:
            want = set(m.upper() for m in (methods or set()))
            for r in app.url_map.iter_rules():
                if str(r.rule) != rule:
                    continue
                if want:
                    existing = set(m.upper() for m in (r.methods or set()))
                    if not want.issubset(existing):
                        continue
                return True
            return False
        except Exception:
            return False

    needed = [
        ("/api/folders", {"POST"}),
        ("/api/chats", {"GET"}),
        ("/api/chats", {"POST"}),
        ("/api/chats/<chat_id>", {"GET", "DELETE", "PATCH"}),
        ("/api/chats/<chat_id>/copy", {"POST"}),
        ("/api/chats/<chat_id>/ui_history", {"GET"}),
        ("/api/chats/<chat_id>/ui_history/logs", {"GET"}),
        ("/api/chats/<chat_id>/ui_history/append_log", {"POST"}),
        ("/api/chats/<chat_id>/ui_history/state", {"GET", "POST"}),
        ("/api/chats/<chat_id>/ui_history/clear", {"DELETE"}),
    ]
    missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
    if not missing:
        return

    # /api/folders
    if any(rule == "/api/folders" for rule, _ in missing):
        def _create_folder():
            data = request.get_json(silent=True) or {}
            folder_name = (data.get("name") or "").strip()
            chat_manager, _ = _lazy_get_managers()
            try:
                folder_name2 = chat_manager.create_folder(folder_name)
                return jsonify({"success": True, "folder_name": folder_name2}), 201
            except ValueError as e:
                return jsonify({"error": str(e)}), 400
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        app.add_url_rule(
            "/api/folders",
            endpoint="rumi_io_http_chats_v1.create_folder",
            view_func=_create_folder,
            methods=["POST"],
        )

    # GET /api/chats
    if any(rule == "/api/chats" and "GET" in methods for rule, methods in missing):
        def _get_all_chats():
            chat_manager, _ = _lazy_get_managers()
            return jsonify(chat_manager.get_all_chats())
        app.add_url_rule(
            "/api/chats",
            endpoint="rumi_io_http_chats_v1.get_all_chats",
            view_func=_get_all_chats,
            methods=["GET"],
        )

    # POST /api/chats
    if any(rule == "/api/chats" and "POST" in methods for rule, methods in missing):
        def _create_new_chat():
            data = request.get_json(silent=True) or {}
            folder_name = data.get("folder", None)
            chat_manager, _ = _lazy_get_managers()
            metadata = chat_manager.create_chat(folder_name)
            return jsonify(metadata), 201
        app.add_url_rule(
            "/api/chats",
            endpoint="rumi_io_http_chats_v1.create_new_chat",
            view_func=_create_new_chat,
            methods=["POST"],
        )

    # /api/chats/<chat_id> (GET/DELETE/PATCH)
    if any(rule == "/api/chats/<chat_id>" for rule, _ in missing):
        def _handle_single_chat(chat_id: str):
            chat_manager, relationship_manager = _lazy_get_managers()
            if request.method == "DELETE":
                try:
                    deleted_links = relationship_manager.delete_all_links_for(chat_id)
                    if deleted_links > 0:
                        print(f"Deleted {deleted_links} relationship links for chat {chat_id}")
                    chat_manager.delete_chat(chat_id)
                    return jsonify({"success": True}), 200
                except FileNotFoundError:
                    return jsonify({"error": "Chat not found"}), 404
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            if request.method == "GET":
                try:
                    data = chat_manager.load_chat_history(chat_id)
                    return jsonify(data)
                except FileNotFoundError:
                    return jsonify({
                        "metadata": {"title": "新しいチャット", "is_pinned": False, "folder": None},
                        "messages": []
                    })

            # PATCH
            try:
                chat_manager.update_chat_metadata(chat_id, request.json)
                return jsonify({"success": True}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        app.add_url_rule(
            "/api/chats/<chat_id>",
            endpoint="rumi_io_http_chats_v1.handle_single_chat",
            view_func=_handle_single_chat,
            methods=["GET", "DELETE", "PATCH"],
        )

    # /api/chats/<chat_id>/copy
    if any(rule == "/api/chats/<chat_id>/copy" for rule, _ in missing):
        def _copy_chat(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                new_chat_id = chat_manager.copy_chat(chat_id)
                return jsonify({"success": True, "new_chat_id": new_chat_id}), 201
            except FileNotFoundError:
                return jsonify({"error": "Source chat not found"}), 404
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        app.add_url_rule(
            "/api/chats/<chat_id>/copy",
            endpoint="rumi_io_http_chats_v1.copy_chat",
            view_func=_copy_chat,
            methods=["POST"],
        )

    # ui_history (5 routes)
    if any(rule == "/api/chats/<chat_id>/ui_history" for rule, _ in missing):
        def _get_ui_history(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                ui_data = chat_manager.load_ui_history(chat_id)
                return jsonify(ui_data), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        app.add_url_rule(
            "/api/chats/<chat_id>/ui_history",
            endpoint="rumi_io_http_chats_v1.get_ui_history",
            view_func=_get_ui_history,
            methods=["GET"],
        )

    if any(rule == "/api/chats/<chat_id>/ui_history/logs" for rule, _ in missing):
        def _get_ui_history_logs(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                ui_data = chat_manager.load_ui_history(chat_id)
                execution_id = request.args.get("execution_id")
                if execution_id:
                    logs = chat_manager.get_tool_logs_for_execution(chat_id, execution_id)
                else:
                    logs = ui_data.get("tool_logs", [])
                return jsonify({"logs": logs}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        app.add_url_rule(
            "/api/chats/<chat_id>/ui_history/logs",
            endpoint="rumi_io_http_chats_v1.get_ui_history_logs",
            view_func=_get_ui_history_logs,
            methods=["GET"],
        )

    if any(rule == "/api/chats/<chat_id>/ui_history/append_log" for rule, _ in missing):
        def _append_ui_log(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                log_entry = request.get_json(silent=True) or {}
                message_id = chat_manager.append_tool_log(chat_id, log_entry)
                return jsonify({"success": True, "message_id": message_id}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        app.add_url_rule(
            "/api/chats/<chat_id>/ui_history/append_log",
            endpoint="rumi_io_http_chats_v1.append_ui_log",
            view_func=_append_ui_log,
            methods=["POST"],
        )

    if any(rule == "/api/chats/<chat_id>/ui_history/state" for rule, _ in missing):
        def _handle_ui_state(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                if request.method == "GET":
                    ui_data = chat_manager.load_ui_history(chat_id)
                    return jsonify({"ui_state": ui_data.get("ui_state", {})}), 200
                state_updates = request.get_json(silent=True) or {}
                for key, value in state_updates.items():
                    chat_manager.update_ui_state(chat_id, key, value)
                return jsonify({"success": True}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        app.add_url_rule(
            "/api/chats/<chat_id>/ui_history/state",
            endpoint="rumi_io_http_chats_v1.handle_ui_state",
            view_func=_handle_ui_state,
            methods=["GET", "POST"],
        )

    if any(rule == "/api/chats/<chat_id>/ui_history/clear" for rule, _ in missing):
        def _clear_ui_history(chat_id: str):
            chat_manager, _ = _lazy_get_managers()
            try:
                chat_manager.clear_ui_history(chat_id)
                return jsonify({"success": True}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        app.add_url_rule(
            "/api/chats/<chat_id>/ui_history/clear",
            endpoint="rumi_io_http_chats_v1.clear_ui_history",
            view_func=_clear_ui_history,
            methods=["DELETE"],
        )
これで「一度登録したら後から増やせない」問題が、chats系でも起きません。

修正: ecosystem/default/backend/components/io_http_relationships/setup.py
Blueprint方式を廃止して add_url_rule 化（順不同・部分削除OK）。

Copy# --- 修正箇所: ecosystem/default/backend/components/io_http_relationships/setup.py ---
# bind_http 関数を丸ごと置換（legacyルート自動スキップも url_map で担保できるので簡素化）

def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
    from flask import request, jsonify
    from relationship_manager import RelationshipManager

    def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
        try:
            want = set(m.upper() for m in (methods or set()))
            for r in app.url_map.iter_rules():
                if str(r.rule) != rule:
                    continue
                if want:
                    existing = set(m.upper() for m in (r.methods or set()))
                    if not want.issubset(existing):
                        continue
                return True
            return False
        except Exception:
            return False

    needed = [
        ("/api/relationships", {"GET", "POST"}),
        ("/api/relationships/<entity_id>", {"GET", "DELETE"}),
    ]
    missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
    if not missing:
        return

    relationship_manager = RelationshipManager()

    if any(rule == "/api/relationships" for rule, _ in missing):
        def _handle_relationships():
            if request.method == "GET":
                entity_id = request.args.get("entity_id")
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")
                if entity_id:
                    links = relationship_manager.get_related(entity_id, link_type, direction)
                else:
                    links = relationship_manager.get_all_links()
                return jsonify({"links": links}), 200

            data = request.get_json(silent=True) or {}
            required_fields = ["source", "target", "type"]
            for field in required_fields:
                if field not in data:
                    return jsonify({"error": f"{field} is required"}), 400

            try:
                link = relationship_manager.link(
                    source=data["source"],
                    target=data["target"],
                    link_type=data["type"],
                    metadata=data.get("metadata", {}),
                )
                return jsonify({"success": True, "link": link}), 201
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        app.add_url_rule(
            "/api/relationships",
            endpoint="rumi_io_http_relationships_v1.handle_relationships",
            view_func=_handle_relationships,
            methods=["GET", "POST"],
        )

    if any(rule == "/api/relationships/<entity_id>" for rule, _ in missing):
        def _handle_entity_relationships(entity_id: str):
            if request.method == "GET":
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")
                links = relationship_manager.get_related(entity_id, link_type, direction)
                ids = relationship_manager.get_related_ids(entity_id, link_type, direction)
                return jsonify({"entity_id": entity_id, "links": links, "related_ids": ids}), 200

            data = request.get_json(silent=True) or {}
            target = data.get("target")
            link_type = data.get("type")
            if target and link_type:
                success = relationship_manager.unlink(entity_id, target, link_type)
                return jsonify({"success": success}), 200 if success else 404
            count = relationship_manager.delete_all_links_for(entity_id)
            return jsonify({"success": True, "deleted_count": count}), 200

        app.add_url_rule(
            "/api/relationships/<entity_id>",
            endpoint="rumi_io_http_relationships_v1.handle_entity_relationships",
            view_func=_handle_entity_relationships,
            methods=["GET", "DELETE"],
        )
修正: ecosystem/default/backend/components/io_http_user_settings/setup.py
Blueprint方式→add_url_rule 化（部分削除OK）。

Copy# --- 修正箇所: ecosystem/default/backend/components/io_http_user_settings/setup.py ---
# bind_http 関数を丸ごと置換

def bind_http(app, kernel, ctx: Optional[Dict] = None) -> None:
    from flask import request, jsonify
    from settings_manager import SettingsManager

    def _route_exists(rule: str, methods: Optional[set] = None) -> bool:
        try:
            want = set(m.upper() for m in (methods or set()))
            for r in app.url_map.iter_rules():
                if str(r.rule) != rule:
                    continue
                if want:
                    existing = set(m.upper() for m in (r.methods or set()))
                    if not want.issubset(existing):
                        continue
                return True
            return False
        except Exception:
            return False

    if _route_exists("/api/user/settings", {"GET", "POST"}):
        return

    settings_manager = SettingsManager()

    def _user_settings_api():
        if request.method == "GET":
            return jsonify(settings_manager.get_user_settings())
        data = request.get_json(silent=True)
        if not isinstance(data, dict):
            data = {}
        settings_manager.save_user_settings(data)
        return jsonify({"success": True}), 200

    app.add_url_rule(
        "/api/user/settings",
        endpoint="rumi_io_http_user_settings_v1.user_settings_api",
        view_func=_user_settings_api,
        methods=["GET", "POST"],
    )


Step 12-A（新規）: io_http_tools_api_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_tools_api/manifest.json
Copy{
  "type": "io",
  "id": "io_http_tools_api_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Tools API (/api/tools*) を Flask にバインドする（公式 app.py から移管、まずはAPIのみ）"
  }
}
新規: ecosystem/default/backend/components/io_http_tools_api/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set
import json
import time
import subprocess
from pathlib import Path


# module-level cache (binder再実行でも保持)
_STATE: Dict[str, Any] = {
    "ai_manager": None,
    "tool_ui_manager": None,
    "init_attempted": False,
    "init_error": None,
}


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_tools_api.register",
                handler="io_http_tools_api:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify, Response

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        needed = [
            ("/api/tools/messages", {"GET"}),
            ("/api/tools/messages/stream", {"GET"}),
            ("/api/tools/ui/<tool_name>", {"GET"}),
            ("/api/tools/<tool_name>/start_ui", {"POST"}),
            ("/api/tools/reload", {"POST"}),
            ("/api/tools/settings", {"GET"}),
            ("/api/tools/settings/<tool_name>", {"POST"}),
            ("/api/tools/settings/<tool_name>", {"DELETE"}),
            ("/api/tools/<tool_name>/venv-status", {"GET"}),
            ("/api/tools/debug", {"GET"}),
            ("/api/test/tool_execution", {"GET"}),
            ("/api/tools/ui/status", {"GET"}),
            ("/api/tools/<tool_name>/ui/start", {"POST"}),
            ("/api/tools/<tool_name>/ui/stop", {"POST"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return

        def _ensure_runtime():
            if _STATE["ai_manager"] is not None and _STATE["tool_ui_manager"] is not None:
                return True
            if _STATE["init_attempted"]:
                return False

            _STATE["init_attempted"] = True
            # 暫定: app.py のグローバルを参照（移行中ブリッジ）
            try:
                import app as app_module  # type: ignore
                _STATE["ai_manager"] = getattr(app_module, "ai_manager", None)
                _STATE["tool_ui_manager"] = getattr(app_module, "tool_ui_manager", None)
                return True
            except Exception as e:
                _STATE["init_error"] = f"{type(e).__name__}: {e}"
                return False

        def _get_ai_manager():
            _ensure_runtime()
            return _STATE.get("ai_manager")

        def _get_tool_ui_manager():
            _ensure_runtime()
            return _STATE.get("tool_ui_manager")

        # -------------------------
        # GET /api/tools/messages
        # -------------------------
        if any(rule == "/api/tools/messages" for rule, _ in missing):
            def _get_tool_messages():
                ai = _get_ai_manager()
                messages = ai.tool_loader.get_tool_messages() if ai and getattr(ai, "tool_loader", None) else []
                return jsonify(messages)

            app.add_url_rule(
                "/api/tools/messages",
                endpoint="rumi_io_http_tools_api_v1.get_tool_messages",
                view_func=_get_tool_messages,
                methods=["GET"],
            )

        # -------------------------
        # GET /api/tools/messages/stream (SSE)
        # -------------------------
        if any(rule == "/api/tools/messages/stream" for rule, _ in missing):
            def _stream_tool_messages():
                ai = _get_ai_manager()

                def generate():
                    while True:
                        msgs = ai.tool_loader.get_tool_messages() if ai and getattr(ai, "tool_loader", None) else []
                        for msg in msgs:
                            yield f"data: {json.dumps(msg, ensure_ascii=False)}\n\n"
                        time.sleep(0.1)

                return Response(generate(), mimetype="text/event-stream")

            app.add_url_rule(
                "/api/tools/messages/stream",
                endpoint="rumi_io_http_tools_api_v1.stream_tool_messages",
                view_func=_stream_tool_messages,
                methods=["GET"],
            )

        # -------------------------
        # GET /api/tools/ui/<tool_name>
        # -------------------------
        if any(rule == "/api/tools/ui/<tool_name>" for rule, _ in missing):
            def _get_tool_ui_info(tool_name: str):
                ai = _get_ai_manager()
                if not ai or not getattr(ai, "tool_loader", None) or tool_name not in ai.tool_loader.loaded_tools:
                    return jsonify({"error": "Tool not found"}), 404

                tool_info = ai.tool_loader.loaded_tools[tool_name]
                return jsonify({
                    "has_ui": tool_info.get("has_ui", False),
                    "html_file": tool_info.get("html_file", "index.html"),
                    "icon": tool_info.get("icon", ""),
                    "name": tool_info.get("name", "")
                })

            app.add_url_rule(
                "/api/tools/ui/<tool_name>",
                endpoint="rumi_io_http_tools_api_v1.get_tool_ui_info",
                view_func=_get_tool_ui_info,
                methods=["GET"],
            )

        # -------------------------
        # POST /api/tools/<tool_name>/start_ui (legacy direct start_ui_server)
        # -------------------------
        if any(rule == "/api/tools/<tool_name>/start_ui" for rule, _ in missing):
            def _start_tool_ui(tool_name: str):
                ai = _get_ai_manager()
                if not ai or not getattr(ai, "tool_loader", None) or tool_name not in ai.tool_loader.loaded_tools:
                    return jsonify({"error": "Tool not found"}), 404

                tool_info = ai.tool_loader.loaded_tools[tool_name]
                module = tool_info.get("module")

                if module and hasattr(module, "start_ui_server"):
                    ui_port = module.start_ui_server()
                    if ui_port:
                        return jsonify({
                            "success": True,
                            "ui_port": ui_port,
                            "html_file": tool_info.get("html_file", "index.html"),
                        })
                return jsonify({"error": "Tool does not support UI"}), 400

            app.add_url_rule(
                "/api/tools/<tool_name>/start_ui",
                endpoint="rumi_io_http_tools_api_v1.start_tool_ui",
                view_func=_start_tool_ui,
                methods=["POST"],
            )

        # -------------------------
        # POST /api/tools/reload
        # -------------------------
        if any(rule == "/api/tools/reload" for rule, _ in missing):
            def _reload_tools():
                ai = _get_ai_manager()
                try:
                    result = ai.tool_loader.reload_all_tools() if ai else {"success": False, "error": "AI manager not initialized"}
                    return jsonify(result), 200
                except Exception as e:
                    return jsonify({"success": False, "error": str(e)}), 500

            app.add_url_rule(
                "/api/tools/reload",
                endpoint="rumi_io_http_tools_api_v1.reload_tools",
                view_func=_reload_tools,
                methods=["POST"],
            )

        # -------------------------
        # GET /api/tools/settings
        # -------------------------
        if any(rule == "/api/tools/settings" for rule, _ in missing):
            def _get_tools_settings():
                ai = _get_ai_manager()
                tools_data = ai.tool_loader.get_all_tools_with_settings() if ai else {}
                return jsonify(tools_data)

            app.add_url_rule(
                "/api/tools/settings",
                endpoint="rumi_io_http_tools_api_v1.get_tools_settings",
                view_func=_get_tools_settings,
                methods=["GET"],
            )

        # -------------------------
        # POST /api/tools/settings/<tool_name>
        # -------------------------
        if any(rule == "/api/tools/settings/<tool_name>" and "POST" in methods for rule, methods in missing):
            def _update_tool_settings(tool_name: str):
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"success": False, "error": "AI manager not initialized"}), 500
                settings = request.get_json(silent=True)
                if not isinstance(settings, dict):
                    settings = {}
                success = ai.tool_loader.update_tool_settings(tool_name, settings)
                if success:
                    return jsonify({"success": True})
                return jsonify({"success": False, "error": "Failed to update settings"}), 500

            app.add_url_rule(
                "/api/tools/settings/<tool_name>",
                endpoint="rumi_io_http_tools_api_v1.update_tool_settings",
                view_func=_update_tool_settings,
                methods=["POST"],
            )

        # -------------------------
        # DELETE /api/tools/settings/<tool_name>
        # -------------------------
        if any(rule == "/api/tools/settings/<tool_name>" and "DELETE" in methods for rule, methods in missing):
            def _delete_tool_settings(tool_name: str):
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"success": False, "error": "AI manager not initialized"}), 500

                if tool_name in ai.tool_loader.tool_settings:
                    del ai.tool_loader.tool_settings[tool_name]
                    ai.tool_loader._save_settings()
                    return jsonify({"success": True})
                return jsonify({"success": False, "error": "Tool settings not found"}), 404

            app.add_url_rule(
                "/api/tools/settings/<tool_name>",
                endpoint="rumi_io_http_tools_api_v1.delete_tool_settings",
                view_func=_delete_tool_settings,
                methods=["DELETE"],
            )

        # -------------------------
        # GET /api/tools/<tool_name>/venv-status
        # -------------------------
        if any(rule == "/api/tools/<tool_name>/venv-status" for rule, _ in missing):
            def _get_tool_venv_status(tool_name: str):
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                tool_info = ai.tool_loader.loaded_tools.get(tool_name) if getattr(ai, "tool_loader", None) else None
                if not tool_info:
                    return jsonify({"error": "Tool not found"}), 404

                tool_dir = Path(tool_info["tool_dir"])
                venv_dir = tool_dir / ".venv"
                requirements_file = tool_dir / "requirements.txt"

                status = {
                    "has_requirements": requirements_file.exists(),
                    "has_venv": venv_dir.exists(),
                    "venv_python": tool_info.get("venv_python"),
                    "packages": []
                }

                if status["has_venv"] and tool_info.get("venv_python"):
                    try:
                        result = subprocess.run(
                            [tool_info["venv_python"], "-m", "pip", "list", "--format=json"],
                            capture_output=True,
                            text=True,
                            timeout=10
                        )
                        if result.returncode == 0:
                            status["packages"] = json.loads(result.stdout)
                    except Exception:
                        pass

                return jsonify(status)

            app.add_url_rule(
                "/api/tools/<tool_name>/venv-status",
                endpoint="rumi_io_http_tools_api_v1.get_tool_venv_status",
                view_func=_get_tool_venv_status,
                methods=["GET"],
            )

        # -------------------------
        # GET /api/tools/debug
        # -------------------------
        if any(rule == "/api/tools/debug" for rule, _ in missing):
            def _debug_tools():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"total_tools": 0, "tools": {}, "duplicates": {}, "has_duplicates": False}), 200

                tools_info = {}
                for tool_name, tool_data in ai.tool_loader.loaded_tools.items():
                    tools_info[tool_name] = {
                        "display_name": tool_data["name"],
                        "function_name": tool_data["function_declaration"]["name"],
                        "file_path": tool_data["file_path"],
                        "tool_dir": tool_data["tool_dir"]
                    }

                function_names: Dict[str, list] = {}
                for tool_name, info in tools_info.items():
                    func_name = info["function_name"]
                    function_names.setdefault(func_name, []).append(info)

                duplicates = {k: v for k, v in function_names.items() if len(v) > 1}

                return jsonify({
                    "total_tools": len(tools_info),
                    "tools": tools_info,
                    "duplicates": duplicates,
                    "has_duplicates": len(duplicates) > 0
                })

            app.add_url_rule(
                "/api/tools/debug",
                endpoint="rumi_io_http_tools_api_v1.debug_tools",
                view_func=_debug_tools,
                methods=["GET"],
            )

        # -------------------------
        # GET /api/test/tool_execution
        # -------------------------
        if any(rule == "/api/test/tool_execution" for rule, _ in missing):
            def _test_tool_execution():
                ai = _get_ai_manager()
                # chat_manager は app.py のグローバルを暫定参照
                try:
                    import app as app_module  # type: ignore
                    chat_manager = getattr(app_module, "chat_manager", None)
                except Exception:
                    chat_manager = None

                try:
                    if ai and getattr(ai, "tool_loader", None):
                        test_context = {"chat_id": "test-chat", "execution_id": "test-exec", "chat_manager": chat_manager}
                        if "web_search" in ai.tool_loader.loaded_tools:
                            result = ai.tool_loader.execute_tool("web_search", {"query": "test"}, test_context)
                            return jsonify({"success": True, "result": str(result)})
                        return jsonify({"error": "web_search tool not found"})
                    return jsonify({"error": "AI manager or tool loader not initialized"})
                except Exception as e:
                    import traceback
                    return jsonify({"error": str(e), "trace": traceback.format_exc()})

            app.add_url_rule(
                "/api/test/tool_execution",
                endpoint="rumi_io_http_tools_api_v1.test_tool_execution",
                view_func=_test_tool_execution,
                methods=["GET"],
            )

        # -------------------------
        # GET /api/tools/ui/status
        # -------------------------
        if any(rule == "/api/tools/ui/status" for rule, _ in missing):
            def _get_ui_servers_status():
                tum = _get_tool_ui_manager()
                active_servers = tum.get_active_servers() if tum else {}
                return jsonify({"active_count": len(active_servers), "servers": active_servers})

            app.add_url_rule(
                "/api/tools/ui/status",
                endpoint="rumi_io_http_tools_api_v1.get_ui_servers_status",
                view_func=_get_ui_servers_status,
                methods=["GET"],
            )

        # -------------------------
        # POST /api/tools/<tool_name>/ui/start
        # -------------------------
        if any(rule == "/api/tools/<tool_name>/ui/start" for rule, _ in missing):
            def _start_tool_ui_server(tool_name: str):
                ai = _get_ai_manager()
                tum = _get_tool_ui_manager()
                if not ai or not getattr(ai, "tool_loader", None) or tool_name not in ai.tool_loader.loaded_tools:
                    return jsonify({"error": "Tool not found"}), 404

                tool_info = ai.tool_loader.loaded_tools[tool_name]
                ui_info = tum.start_tool_ui(tool_name, tool_info) if tum else None
                if ui_info:
                    return jsonify(ui_info), 200
                return jsonify({"error": "Failed to start UI server"}), 500

            app.add_url_rule(
                "/api/tools/<tool_name>/ui/start",
                endpoint="rumi_io_http_tools_api_v1.start_tool_ui_server",
                view_func=_start_tool_ui_server,
                methods=["POST"],
            )

        # -------------------------
        # POST /api/tools/<tool_name>/ui/stop
        # -------------------------
        if any(rule == "/api/tools/<tool_name>/ui/stop" for rule, _ in missing):
            def _stop_tool_ui_server(tool_name: str):
                tum = _get_tool_ui_manager()
                success = tum.stop_tool_ui(tool_name) if tum else False
                if success:
                    return jsonify({"success": True}), 200
                return jsonify({"error": "Server not found or failed to stop"}), 404

            app.add_url_rule(
                "/api/tools/<tool_name>/ui/stop",
                endpoint="rumi_io_http_tools_api_v1.stop_tool_ui_server",
                view_func=_stop_tool_ui_server,
                methods=["POST"],
            )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_tools_api_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_tools_api.register",
            handler="io_http_tools_api:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/tools/* (api-only)"],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 12-B（既存修正）: app.py から tools API ルートを削除（/tools/<tool_name> 配信は残す）
以下の API系ルートブロックを app.py から削除してください（正確に“その関数ブロック全体”を削除）。
残すもの：serve_tool_ui（/tools/<tool_name>/...）と WebSocket 部分（flask-sock）と get_tool_data/send_data_to_tool 系（次ステップで移管予定）

修正: app.py（削除するブロック一覧）
削除: ツール関連API
get_tool_messages
Copy@app.route('/api/tools/messages', methods=['GET'])
def get_tool_messages():
    ...
stream_tool_messages
Copy@app.route('/api/tools/messages/stream', methods=['GET'])
def stream_tool_messages():
    ...
get_tool_ui_info
Copy@app.route('/api/tools/ui/<tool_name>', methods=['GET'])
def get_tool_ui_info(tool_name):
    ...
start_tool_ui
Copy@app.route('/api/tools/<tool_name>/start_ui', methods=['POST'])
def start_tool_ui(tool_name):
    ...
reload_tools
Copy@app.route('/api/tools/reload', methods=['POST'])
def reload_tools():
    ...
get_tools_settings
Copy@app.route('/api/tools/settings', methods=['GET'])
def get_tools_settings():
    ...
update_tool_settings
Copy@app.route('/api/tools/settings/<tool_name>', methods=['POST'])
def update_tool_settings(tool_name):
    ...
delete_tool_settings
Copy@app.route('/api/tools/settings/<tool_name>', methods=['DELETE'])
def delete_tool_settings(tool_name):
    ...
get_tool_venv_status
Copy@app.route('/api/tools/<tool_name>/venv-status', methods=['GET'])
def get_tool_venv_status(tool_name):
    ...
debug_tools
Copy@app.route('/api/tools/debug', methods=['GET'])
def debug_tools():
    ...
test_tool_execution
Copy@app.route('/api/test/tool_execution')
def test_tool_execution():
    ...
get_ui_servers_status
Copy@app.route('/api/tools/ui/status', methods=['GET'])
def get_ui_servers_status():
    ...
start_tool_ui_server
Copy@app.route('/api/tools/<tool_name>/ui/start', methods=['POST'])
def start_tool_ui_server(tool_name):
    ...
stop_tool_ui_server
Copy@app.route('/api/tools/<tool_name>/ui/stop', methods=['POST'])
def stop_tool_ui_server(tool_name):
    ...
次（Step13）
次は tool_data_api（/api/tools/<tool_name>/data）と get_tool_data/send_data_to_tool を ecosystem に移し、さらに /tools/<tool_name>/ の静的配信・WebSocket をどう扱うか（“os的に”どのcomponentが静的資産を出すか）を固めます。

Notionに保存
step13に進んでください。自信度maxの完璧なものをお願いします。ultra think
💭 think1 [heavy] [lang:JA] Goal: Step13 migrate /api/tools/<tool_name>/data (and its helper functions) from app.py to ecosystem with order-independent partial deletion safety and no route-collision risk; Assumptions: /tools/<tool_name>/ static UI + websocket remain in app.py for now, tool_data_api currently depends on ai_manager.tool_loader and module.ui_data/ui_update; Plan: add io_http_tool_data_v1 component using per-route app.add_url_rule with url_map existence check; implement GET returns tool info + module.ui_data, POST calls module.ui_update; use lazy runtime access via importing app.ai_manager temporarily; then delete exact tool_data_api + get_tool_data + send_data_to_tool blocks from app.py; Checks: endpoint parity/status codes, handles missing tool or missing ui_update gracefully, no duplicate route crashes if legacy still present; Risks: temporary coupling via import app, module.ui_data mutable; Mitigation: fail-soft errors, later replace with InterfaceRegistry tools.runtime; Alternatives: keep helpers in app.py unused (but goal is thinning official). ✓ 96% 🔍 think2 Verify: with legacy route present binder adds nothing; after deleting legacy route binder adds it; GET returns same shape as before, POST returns same shape, tool not found returns 404-like payload, and no Flask AssertionError about duplicate endpoint names. ✓ 99% 🔧 think3 Improve: next step move /tools/<tool_name>/ static hosting + websocket into ecosystem IO components and publish a tools.ui_registry interface to avoid app-module imports entirely. ✓ 99% 🔧 think4 Improve: add optional auth/CSRF policy layer for tool data endpoints later via a generic middleware component (kernel remains neutral). ✓ 99%

Step13：/api/tools/<tool_name>/data（tool_data_api）と、その補助関数（get_tool_data/send_data_to_tool）を ecosystem 側へ移管します。今回も add_url_rule + ルート存在チェックで段階移行に強くします。

Step 13-A（新規）: io_http_tool_data_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_tool_data/manifest.json
Copy{
  "type": "io",
  "id": "io_http_tool_data_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Tool data API (/api/tools/<tool_name>/data) を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_tool_data/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set


_STATE: Dict[str, Any] = {
    "ai_manager": None,
    "init_attempted": False,
    "init_error": None,
}


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_tool_data.register",
                handler="io_http_tool_data:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        # 段階移行に強い：このルートが無い時だけ追加
        rule = "/api/tools/<tool_name>/data"
        if _route_exists(rule, {"GET", "POST"}):
            return

        def _ensure_ai_manager():
            if _STATE["ai_manager"] is not None:
                return True
            if _STATE["init_attempted"]:
                return False
            _STATE["init_attempted"] = True

            # 暫定ブリッジ：app.py のグローバル ai_manager を参照
            try:
                import app as app_module  # type: ignore
                _STATE["ai_manager"] = getattr(app_module, "ai_manager", None)
                return True
            except Exception as e:
                _STATE["init_error"] = f"{type(e).__name__}: {e}"
                return False

        def _get_ai_manager():
            _ensure_ai_manager()
            return _STATE.get("ai_manager")

        def _get_tool_data(tool_name: str) -> Dict[str, Any]:
            ai = _get_ai_manager()
            if ai and getattr(ai, "tool_loader", None) and tool_name in ai.tool_loader.loaded_tools:
                tool_info = ai.tool_loader.loaded_tools[tool_name]
                module = tool_info.get("module")

                tool_data_store = {}
                try:
                    tool_data_store = getattr(module, "ui_data", {}) if module else {}
                except Exception:
                    tool_data_store = {}

                return {
                    "name": tool_info.get("name", tool_name),
                    "description": tool_info.get("description", ""),
                    "icon": tool_info.get("icon", ""),
                    "data": tool_data_store,
                    "status": "loaded",
                }

            return {"status": "not_loaded", "error": f"Tool {tool_name} not found"}

        def _send_data_to_tool(tool_name: str, data: Any) -> Dict[str, Any]:
            ai = _get_ai_manager()
            if ai and getattr(ai, "tool_loader", None) and tool_name in ai.tool_loader.loaded_tools:
                tool_info = ai.tool_loader.loaded_tools[tool_name]
                module = tool_info.get("module")
                if module and hasattr(module, "ui_update"):
                    try:
                        result = module.ui_update(data)
                        return {"success": True, "result": result}
                    except Exception as e:
                        return {"success": False, "error": str(e)}
                return {"success": False, "error": f"Tool {tool_name} does not support UI updates"}

            return {"success": False, "error": f"Tool {tool_name} not found"}

        def _tool_data_api(tool_name: str):
            if request.method == "GET":
                return jsonify(_get_tool_data(tool_name))
            # POST
            data = request.get_json(silent=True)
            result = _send_data_to_tool(tool_name, data)
            return jsonify(result)

        app.add_url_rule(
            "/api/tools/<tool_name>/data",
            endpoint="rumi_io_http_tool_data_v1.tool_data_api",
            view_func=_tool_data_api,
            methods=["GET", "POST"],
        )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_tool_data_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_tool_data.register",
            handler="io_http_tool_data:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/tools/<tool_name>/data"],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 13-B（既存修正）: app.py から /api/tools/<tool_name>/data と補助関数を削除
以下の 3ブロックを app.py から削除してください（完全一致で、他は触りません）。

修正: app.py
1) tool_data_api（/api/tools/<tool_name>/data）
削除：次のブロック全体

Copy@app.route('/api/tools/<tool_name>/data', methods=['GET', 'POST'])
def tool_data_api(tool_name):
    """ツール固有のデータAPI"""
    if request.method == 'GET':
        # ツールのデータを取得
        tool_data = get_tool_data(tool_name)
        return jsonify(tool_data)
    
    elif request.method == 'POST':
        # ツールにデータを送信
        data = request.json
        result = send_data_to_tool(tool_name, data)
        return jsonify(result)
2) get_tool_data（補助関数）
削除：次のブロック全体

Copydef get_tool_data(tool_name):
    """ツールのデータを取得"""
    # ツールローダーから情報を取得
    if ai_manager and tool_name in ai_manager.tool_loader.loaded_tools:
        tool_info = ai_manager.tool_loader.loaded_tools[tool_name]
        
        # ツール固有のデータストアがあれば取得
        tool_data_store = getattr(tool_info.get('module'), 'ui_data', {})
        
        return {
            'name': tool_info['name'],
            'description': tool_info['description'],
            'icon': tool_info['icon'],
            'data': tool_data_store,
            'status': 'loaded'
        }
    
    return {'status': 'not_loaded', 'error': f'Tool {tool_name} not found'}
3) send_data_to_tool（補助関数）
削除：次のブロック全体

Copydef send_data_to_tool(tool_name, data):
    """ツールにデータを送信"""
    if ai_manager and tool_name in ai_manager.tool_loader.loaded_tools:
        tool_info = ai_manager.tool_loader.loaded_tools[tool_name]
        module = tool_info.get('module')
        
        # ツールにui_update関数があれば呼び出し
        if hasattr(module, 'ui_update'):
            result = module.ui_update(data)
            return {'success': True, 'result': result}
    
    return {'success': False, 'error': f'Tool {tool_name} not found or does not support UI updates'}




Step 14-A（新規）: io_http_ai_api_v1 コンポーネント追加
新規: ecosystem/default/backend/components/io_http_ai_api/manifest.json
Copy{
  "type": "io",
  "id": "io_http_ai_api_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "AI API (/api/ai/*) と debug logging API を Flask にバインドする（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_ai_api/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set


_STATE: Dict[str, Any] = {
    "ai_manager": None,
    "init_attempted": False,
    "init_error": None,
}


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_ai_api.register",
                handler="io_http_ai_api:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        needed = [
            ("/api/ai/models", {"GET"}),
            ("/api/ai/models/search", {"POST"}),
            ("/api/ai/test", {"GET"}),
            ("/api/ai/favorites", {"GET"}),
            ("/api/ai/favorites", {"POST"}),
            ("/api/ai/favorites/<model_id>", {"DELETE"}),
            ("/api/ai/set-model", {"POST"}),
            ("/api/debug/logging", {"POST"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return

        def _ensure_ai_manager():
            if _STATE["ai_manager"] is not None:
                return True
            if _STATE["init_attempted"]:
                return False
            _STATE["init_attempted"] = True

            # 暫定: app.py のグローバル ai_manager を参照（移行中ブリッジ）
            try:
                import app as app_module  # type: ignore
                _STATE["ai_manager"] = getattr(app_module, "ai_manager", None)
                return True
            except Exception as e:
                _STATE["init_error"] = f"{type(e).__name__}: {e}"
                return False

        def _get_ai_manager():
            _ensure_ai_manager()
            return _STATE.get("ai_manager")

        def _get_settings_manager():
            from settings_manager import SettingsManager
            return SettingsManager()

        # -------------------------
        # GET /api/ai/models
        # -------------------------
        if any(rule == "/api/ai/models" for rule, _ in missing):
            def _get_ai_models():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                models = ai.get_available_models()
                return jsonify({"success": True, "models": models, "count": len(models)})

            app.add_url_rule(
                "/api/ai/models",
                endpoint="rumi_io_http_ai_api_v1.get_ai_models",
                view_func=_get_ai_models,
                methods=["GET"],
            )

        # -------------------------
        # POST /api/ai/models/search
        # -------------------------
        if any(rule == "/api/ai/models/search" for rule, _ in missing):
            def _search_ai_models():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                criteria = request.get_json(silent=True) or {}
                if not isinstance(criteria, dict):
                    criteria = {}

                models = ai.search_models(**criteria)
                return jsonify({"success": True, "models": models, "count": len(models)})

            app.add_url_rule(
                "/api/ai/models/search",
                endpoint="rumi_io_http_ai_api_v1.search_ai_models",
                view_func=_search_ai_models,
                methods=["POST"],
            )

        # -------------------------
        # GET /api/ai/test
        # -------------------------
        if any(rule == "/api/ai/test" for rule, _ in missing):
            def _test_ai_system():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                test_results = {
                    "ai_manager_initialized": True,
                    "ai_loader_initialized": ai.ai_loader is not None,
                    "loaded_providers": list(ai.ai_loader.loaded_clients.keys()) if ai.ai_loader else [],
                    "total_models": len(ai.ai_loader.model_profiles) if ai.ai_loader else 0,
                    "current_provider": ai.current_provider,
                    "current_model": ai.current_model_id,
                    "tool_loader_initialized": ai.tool_loader is not None,
                    "loaded_tools": len(ai.tool_loader.loaded_tools) if ai.tool_loader else 0,
                }
                return jsonify(test_results)

            app.add_url_rule(
                "/api/ai/test",
                endpoint="rumi_io_http_ai_api_v1.test_ai_system",
                view_func=_test_ai_system,
                methods=["GET"],
            )

        # -------------------------
        # GET /api/ai/favorites
        # -------------------------
        if any(rule == "/api/ai/favorites" and "GET" in methods for rule, methods in missing):
            def _get_favorite_models():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                try:
                    sm = _get_settings_manager()
                    user_settings = sm.get_user_settings()
                    favorite_model_ids = user_settings.get("favorite_models", [])

                    favorite_models = []
                    for model_id in favorite_model_ids:
                        profile = ai.ai_loader.get_model_profile(model_id) if ai.ai_loader else None
                        if profile:
                            favorite_models.append({
                                "id": model_id,
                                "name": profile["basic_info"]["name"],
                                "provider": profile["provider_name"],
                                "description": profile["basic_info"].get("description", ""),
                                "features": profile.get("features", {}),
                            })

                    return jsonify({"success": True, "favorites": favorite_models})
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ai/favorites",
                endpoint="rumi_io_http_ai_api_v1.get_favorite_models",
                view_func=_get_favorite_models,
                methods=["GET"],
            )

        # -------------------------
        # POST /api/ai/favorites
        # -------------------------
        if any(rule == "/api/ai/favorites" and "POST" in methods for rule, methods in missing):
            def _add_favorite_model():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                try:
                    data = request.get_json(silent=True) or {}
                    model_id = data.get("model_id")
                    if not model_id:
                        return jsonify({"error": "model_id is required"}), 400

                    profile = ai.ai_loader.get_model_profile(model_id) if ai.ai_loader else None
                    if not profile:
                        return jsonify({"error": "Model not found"}), 404

                    sm = _get_settings_manager()
                    user_settings = sm.get_user_settings()
                    favorite_models = user_settings.get("favorite_models", [])

                    if model_id not in favorite_models:
                        favorite_models.append(model_id)
                        user_settings["favorite_models"] = favorite_models
                        sm.save_user_settings(user_settings)

                    return jsonify({"success": True, "message": f"{model_id} をお気に入りに追加しました"})
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ai/favorites",
                endpoint="rumi_io_http_ai_api_v1.add_favorite_model",
                view_func=_add_favorite_model,
                methods=["POST"],
            )

        # -------------------------
        # DELETE /api/ai/favorites/<model_id>
        # -------------------------
        if any(rule == "/api/ai/favorites/<model_id>" for rule, _ in missing):
            def _remove_favorite_model(model_id: str):
                try:
                    sm = _get_settings_manager()
                    user_settings = sm.get_user_settings()
                    favorite_models = user_settings.get("favorite_models", [])
                    if model_id in favorite_models:
                        favorite_models.remove(model_id)
                        user_settings["favorite_models"] = favorite_models
                        sm.save_user_settings(user_settings)
                    return jsonify({"success": True, "message": f"{model_id} をお気に入りから削除しました"})
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ai/favorites/<model_id>",
                endpoint="rumi_io_http_ai_api_v1.remove_favorite_model",
                view_func=_remove_favorite_model,
                methods=["DELETE"],
            )

        # -------------------------
        # POST /api/ai/set-model
        # -------------------------
        if any(rule == "/api/ai/set-model" for rule, _ in missing):
            def _set_current_model():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                try:
                    data = request.get_json(silent=True) or {}
                    model_id = data.get("model_id")
                    if not model_id:
                        return jsonify({"error": "model_id is required"}), 400

                    success = ai.set_model(model_id)
                    if success:
                        sm = _get_settings_manager()
                        user_settings = sm.get_user_settings()
                        user_settings["model"] = model_id
                        sm.save_user_settings(user_settings)

                        return jsonify({"success": True, "message": f"モデルを {model_id} に設定しました"})
                    return jsonify({"error": "Failed to set model"}), 500

                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ai/set-model",
                endpoint="rumi_io_http_ai_api_v1.set_current_model",
                view_func=_set_current_model,
                methods=["POST"],
            )

        # -------------------------
        # POST /api/debug/logging
        # -------------------------
        if any(rule == "/api/debug/logging" for rule, _ in missing):
            def _set_debug_logging():
                ai = _get_ai_manager()
                if not ai:
                    return jsonify({"error": "AI manager not initialized"}), 500

                try:
                    data = request.get_json(silent=True) or {}
                    enabled = bool(data.get("enabled", False))
                    ai.set_debug_logging(enabled)
                    return jsonify({"success": True, "enabled": enabled, "log_file": "debug.txt"})
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/debug/logging",
                endpoint="rumi_io_http_ai_api_v1.set_debug_logging",
                view_func=_set_debug_logging,
                methods=["POST"],
            )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_ai_api_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_ai_api.register",
            handler="io_http_ai_api:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/ai/*", "/api/debug/logging"],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 14-B（既存修正）: app.py から AI / debug logging ルートを削除
以下の 8ブロックを app.py から削除してください（完全一致で、他は触りません）。

修正: app.py
1) /api/ai/models（get_ai_models）
削除：

Copy@app.route('/api/ai/models', methods=['GET'])
def get_ai_models():
    """利用可能なAIモデルの一覧を取得"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    models = ai_manager.get_available_models()
    print(f"[DEBUG] 利用可能なモデル数: {len(models)}")
    for model in models:
        print(f"  - {model['id']}: {model['name']} ({model['provider']})")
    
    return jsonify({
        'success': True,
        'models': models,
        'count': len(models)
    })
2) /api/ai/models/search（search_ai_models）
削除：

Copy@app.route('/api/ai/models/search', methods=['POST'])
def search_ai_models():
    """条件に基づいてAIモデルを検索"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    criteria = request.json or {}
    models = ai_manager.search_models(**criteria)
    
    print(f"[DEBUG] 検索条件: {criteria}")
    print(f"[DEBUG] 検索結果: {len(models)}件")
    
    return jsonify({
        'success': True,
        'models': models,
        'count': len(models)
    })
3) /api/ai/test（test_ai_system）
削除：

Copy@app.route('/api/ai/test', methods=['GET'])
def test_ai_system():
    """AIシステムのテスト"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    test_results = {
        'ai_manager_initialized': True,
        'ai_loader_initialized': ai_manager.ai_loader is not None,
        'loaded_providers': list(ai_manager.ai_loader.loaded_clients.keys()),
        'total_models': len(ai_manager.ai_loader.model_profiles),
        'current_provider': ai_manager.current_provider,
        'current_model': ai_manager.current_model_id,
        'tool_loader_initialized': ai_manager.tool_loader is not None,
        'loaded_tools': len(ai_manager.tool_loader.loaded_tools) if ai_manager.tool_loader else 0
    }
    
    print("[DEBUG] AIシステムテスト結果:")
    for key, value in test_results.items():
        print(f"  {key}: {value}")
    
    return jsonify(test_results)
4) /api/ai/favorites（GET）
削除：

Copy@app.route('/api/ai/favorites', methods=['GET'])
def get_favorite_models():
    """お気に入りモデルの一覧を取得"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    try:
        user_settings = settings_manager.get_user_settings()
        favorite_model_ids = user_settings.get('favorite_models', [])
        
        # モデルの詳細情報を取得
        favorite_models = []
        for model_id in favorite_model_ids:
            profile = ai_manager.ai_loader.get_model_profile(model_id)
            if profile:
                favorite_models.append({
                    'id': model_id,
                    'name': profile['basic_info']['name'],
                    'provider': profile['provider_name'],
                    'description': profile['basic_info'].get('description', ''),
                    'features': profile.get('features', {})
                })
        
        return jsonify({
            'success': True,
            'favorites': favorite_models
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500
5) /api/ai/favorites（POST）
削除：

Copy@app.route('/api/ai/favorites', methods=['POST'])
def add_favorite_model():
    """お気に入りにモデルを追加"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    try:
        data = request.json
        model_id = data.get('model_id')
        
        if not model_id:
            return jsonify({'error': 'model_id is required'}), 400
        
        # モデルが存在するか確認
        profile = ai_manager.ai_loader.get_model_profile(model_id)
        if not profile:
            return jsonify({'error': 'Model not found'}), 404
        
        # 現在の設定を取得
        user_settings = settings_manager.get_user_settings()
        favorite_models = user_settings.get('favorite_models', [])
        
        # 重複チェック
        if model_id not in favorite_models:
            favorite_models.append(model_id)
            user_settings['favorite_models'] = favorite_models
            settings_manager.save_user_settings(user_settings)
        
        return jsonify({
            'success': True,
            'message': f'{model_id} をお気に入りに追加しました'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500
6) /api/ai/favorites/<model_id>（DELETE）
削除：

Copy@app.route('/api/ai/favorites/<model_id>', methods=['DELETE'])
def remove_favorite_model(model_id):
    """お気に入りからモデルを削除"""
    try:
        user_settings = settings_manager.get_user_settings()
        favorite_models = user_settings.get('favorite_models', [])
        
        if model_id in favorite_models:
            favorite_models.remove(model_id)
            user_settings['favorite_models'] = favorite_models
            settings_manager.save_user_settings(user_settings)
        
        return jsonify({
            'success': True,
            'message': f'{model_id} をお気に入りから削除しました'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500
7) /api/ai/set-model（set_current_model）
削除：

Copy@app.route('/api/ai/set-model', methods=['POST'])
def set_current_model():
    """現在使用するモデルを設定"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    try:
        data = request.json
        model_id = data.get('model_id')
        
        if not model_id:
            return jsonify({'error': 'model_id is required'}), 400
        
        # モデルを設定
        success = ai_manager.set_model(model_id)
        
        if success:
            # ユーザー設定も更新
            user_settings = settings_manager.get_user_settings()
            user_settings['model'] = model_id
            settings_manager.save_user_settings(user_settings)
            
            return jsonify({
                'success': True,
                'message': f'モデルを {model_id} に設定しました'
            })
        else:
            return jsonify({'error': 'Failed to set model'}), 500
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500
8) /api/debug/logging（set_debug_logging）
削除：

Copy@app.route('/api/debug/logging', methods=['POST'])
def set_debug_logging():
    """デバッグログの有効/無効を設定"""
    if not ai_manager:
        return jsonify({'error': 'AI manager not initialized'}), 500
    
    try:
        data = request.json
        enabled = data.get('enabled', False)
        ai_manager.set_debug_logging(enabled)
        
        return jsonify({
            'success': True,
            'enabled': enabled,
            'log_file': 'debug.txt'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500



Step 15-A（新規）: 旧互換チャット送信APIを提供するコンポーネントを追加
新規: ecosystem/default/backend/components/io_http_legacy_chat_message/manifest.json
Copy{
  "type": "io",
  "id": "io_http_legacy_chat_message_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "旧API互換: /api/chats/<id>/send_message*, /api/stream/abort, /api/chats/<id>/continue, /api/chats/<id>/add_system_message"
  }
}
新規: ecosystem/default/backend/components/io_http_legacy_chat_message/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set
import time


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_legacy_chat_message.register",
                handler="io_http_legacy_chat_message:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        needed = [
            ("/api/chats/<chat_id>/send_message", {"POST"}),
            ("/api/chats/<chat_id>/send_message_stream", {"POST"}),
            ("/api/stream/abort", {"POST"}),
            ("/api/chats/<chat_id>/continue", {"POST"}),
            ("/api/chats/<chat_id>/add_system_message", {"POST"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return

        # --- /api/chats/<id>/send_message (non-stream) ---
        if any(rule == "/api/chats/<chat_id>/send_message" for rule, _ in missing):
            def _send_message(chat_id: str):
                payload = request.get_json(silent=True) or {}
                # 互換: 非ストリーミングは強制的に streaming 無効化
                if isinstance(payload, dict) and payload.get("streaming", False):
                    payload["streaming"] = False
                try:
                    result = kernel.run_message(chat_id, payload)
                    return jsonify(result), 200 if isinstance(result, dict) and result.get("success", True) else 400
                except Exception as e:
                    return jsonify({"success": False, "error": str(e), "chat_id": chat_id}), 500

            app.add_url_rule(
                "/api/chats/<chat_id>/send_message",
                endpoint="rumi_io_http_legacy_chat_message_v1.send_message",
                view_func=_send_message,
                methods=["POST"],
            )

        # --- /api/chats/<id>/send_message_stream (stream) ---
        if any(rule == "/api/chats/<chat_id>/send_message_stream" for rule, _ in missing):
            def _send_message_stream(chat_id: str):
                payload = request.get_json(silent=True) or {}
                if isinstance(payload, dict):
                    payload["streaming"] = True
                try:
                    out = kernel.run_message_stream(chat_id, payload)
                    # Response/iterator/dict を許容（app側がそのまま返す設計）
                    return out
                except Exception as e:
                    return jsonify({"success": False, "error": str(e), "chat_id": chat_id}), 500

            app.add_url_rule(
                "/api/chats/<chat_id>/send_message_stream",
                endpoint="rumi_io_http_legacy_chat_message_v1.send_message_stream",
                view_func=_send_message_stream,
                methods=["POST"],
            )

        # --- /api/stream/abort ---
        if any(rule == "/api/stream/abort" for rule, _ in missing):
            def _abort_stream():
                try:
                    abort_fn = kernel.interface_registry.get("message.abort", strategy="last")
                    if callable(abort_fn):
                        abort_fn()
                    return jsonify({"success": True, "message": "Stream aborted"}), 200
                except Exception as e:
                    return jsonify({"success": False, "error": str(e)}), 500

            app.add_url_rule(
                "/api/stream/abort",
                endpoint="rumi_io_http_legacy_chat_message_v1.abort_stream",
                view_func=_abort_stream,
                methods=["POST"],
            )

        # --- /api/chats/<id>/continue ---
        if any(rule == "/api/chats/<chat_id>/continue" for rule, _ in missing):
            def _continue_message(chat_id: str):
                try:
                    payload = request.get_json(silent=True) or {}
                    continue_message_obj = {"type": "user", "text": "続けてください", "files": []}

                    continue_payload = {
                        "message": continue_message_obj,
                        "model": payload.get("model", "gemini-2.5-flash"),
                        "thinking_budget": payload.get("thinking_budget", 0),
                        "prompt": payload.get("prompt", "normal_prompt"),
                        "streaming": bool(payload.get("streaming", False)),
                        "is_continuation": True,
                    }

                    if continue_payload["streaming"]:
                        out = kernel.run_message_stream(chat_id, continue_payload)
                        return out
                    result = kernel.run_message(chat_id, continue_payload)
                    return jsonify(result)
                except Exception as e:
                    return jsonify({"success": False, "error": str(e), "chat_id": chat_id}), 500

            app.add_url_rule(
                "/api/chats/<chat_id>/continue",
                endpoint="rumi_io_http_legacy_chat_message_v1.continue_message",
                view_func=_continue_message,
                methods=["POST"],
            )

        # --- /api/chats/<id>/add_system_message ---
        # 互換維持のため提供。ただし標準履歴(v2)に system role で追加する。
        if any(rule == "/api/chats/<chat_id>/add_system_message" for rule, _ in missing):
            def _add_system_message(chat_id: str):
                try:
                    data = request.get_json(silent=True) or {}
                    from chat_manager import ChatManager, create_standard_message, add_message_to_history
                    cm = ChatManager()

                    history = cm.load_chat_history(chat_id)
                    sys_text = data.get("text", "")
                    event = data.get("event", "unknown")
                    # eventはメタ扱いにして content へ反映
                    content = f"[{event}] {sys_text}".strip()

                    msg = create_standard_message(
                        role="system",
                        content=content,
                        parent_id=history.get("current_node"),
                        status="completed",
                    )
                    history = add_message_to_history(history, msg)
                    cm.save_chat_history(chat_id, history)
                    return jsonify({"success": True}), 200
                except Exception as e:
                    return jsonify({"success": False, "error": str(e)}), 500

            app.add_url_rule(
                "/api/chats/<chat_id>/add_system_message",
                endpoint="rumi_io_http_legacy_chat_message_v1.add_system_message",
                view_func=_add_system_message,
                methods=["POST"],
            )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_legacy_chat_message_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_legacy_chat_message.register",
            handler="io_http_legacy_chat_message:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": [
                    "/api/chats/<chat_id>/send_message",
                    "/api/chats/<chat_id>/send_message_stream",
                    "/api/stream/abort",
                    "/api/chats/<chat_id>/continue",
                    "/api/chats/<chat_id>/add_system_message"
                ],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 15-B（既存修正）: bridge_message に message.abort を追加（公式からabortを消すため）
修正: ecosystem/default/backend/components/bridge_message/setup.py
run() 内で message.handle / message.handle_stream を register している箇所の近くに、以下を追加してください（既存部分はそのまま、追記のみ）。

Copy# --- 追記箇所: bridge_message/setup.py の run() 内（message_handle/message_handle_stream の下あたり） ---

    def message_abort() -> Dict[str, Any]:
        _ensure_initialized()
        if state.get("handler") is None:
            return {"success": False, "error": "message handler unavailable", "details": state.get("error") or "unknown error"}
        try:
            state["handler"].abort_current_stream()
            return {"success": True}
        except Exception as e:
            if diagnostics:
                diagnostics.record_step(
                    phase="message",
                    step_id="bridge_message.abort",
                    handler="bridge_message:message_abort",
                    status="failed",
                    error={"type": type(e).__name__, "message": str(e), "trace": traceback.format_exc()[-4000:]},
                    meta={},
                )
            return {"success": False, "error": str(e)}

    interface_registry.register(
        "message.abort",
        message_abort,
        meta={"component": "bridge_message_v1", "kind": "callable"},
    )
Step 15-C（既存修正）: app.py から旧チャット送信系ルートを削除（ピンポイント）
以下の 5ブロックを app.py から削除してください（新componentが同一パスを提供するため）。

修正: app.py
1) /api/chats/<chat_id>/send_message（send_message_and_get_response）
削除：このブロック全体

Copy@app.route('/api/chats/<chat_id>/send_message', methods=['POST'])
def send_message_and_get_response(chat_id):
    ...
2) /api/chats/<chat_id>/send_message_stream（send_message_and_get_response_stream）
削除：このブロック全体

Copy@app.route('/api/chats/<chat_id>/send_message_stream', methods=['POST'])
def send_message_and_get_response_stream(chat_id):
    ...
3) /api/stream/abort（abort_stream）
削除：このブロック全体

Copy@app.route('/api/stream/abort', methods=['POST'])
def abort_stream():
    ...
4) /api/chats/<chat_id>/add_system_message（add_system_message）
削除：このブロック全体

Copy@app.route('/api/chats/<chat_id>/add_system_message', methods=['POST'])
def add_system_message(chat_id):
    ...
5) /api/chats/<chat_id>/continue（continue_message）
削除：このブロック全体

Copy@app.route('/api/chats/<chat_id>/continue', methods=['POST'])
def continue_message(chat_id):
    ...
（※ 省略記法ではなく、あなたの app.py 内のそれぞれの関数定義ブロックを丸ごと削除してください）

Step 15-D（既存修正）: app.py から不要になった初期化ブロックを削除（まずは安全に）
prompts/supporters/chat/message が ecosystem に移ったので、app.py 内の以下を削除してOKです（ai_manager と tool_ui_manager は tool UI と websocket が残っているのでまだ残します）。

修正: app.py
削除1) PromptLoader 初期化ブロック（丸ごと削除）
Copy# PromptLoaderのインポートと初期化
try:
    from prompt_loader import PromptLoader
    prompt_loader = PromptLoader()
    prompt_loader.load_all_prompts()
    print(f"読み込まれたプロンプト数: {len(prompt_loader.loaded_prompts)}")
except ImportError as e:
    ...
削除2) SupporterLoader 初期化ブロック（丸ごと削除）
Copy# SupporterLoaderのインポートと初期化
try:
    from supporter.supporter_loader import SupporterLoader
    supporter_loader = SupporterLoader()
    supporter_loader.load_all_supporters()
    ...
削除3) SupporterDependencyManager 初期化ブロック（丸ごと削除）
Copy# SupporterDependencyManagerのインポートと初期化
try:
    from ecosystem.default.backend.components.supporter.supporter_dependency_manager import SupporterDependencyManager
    supporter_dependency_manager = SupporterDependencyManager()
except ImportError:
    ...
削除4) これらの import（使っていなければ削除）
Copyfrom chat_manager import ChatManager
from message_handler import MessageHandler
from relationship_manager import RelationshipManager
削除5) これらの初期化（使っていなければ削除）
Copychat_manager = ChatManager()
relationship_manager = RelationshipManager()

if ai_manager:
    message_handler = MessageHandler(...)
else:
    message_handler = None

Step 16-A（新規）: tool UI 静的配信（HTTP）コンポーネント追加
新規: ecosystem/default/backend/components/io_http_tool_ui_host/manifest.json
Copy{
  "type": "io",
  "id": "io_http_tool_ui_host_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Tool UI static hosting: /tools/<tool_name>/ と /tools/<tool_name>/<path> を提供（公式 app.py から移管）"
  }
}
新規: ecosystem/default/backend/components/io_http_tool_ui_host/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set
import json
import mimetypes
from pathlib import Path


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_tool_ui_host.register",
                handler="io_http_tool_ui_host:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import send_from_directory, abort

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        # 段階移行に強い：存在しない場合だけ追加
        needed = [
            ("/tools/<tool_name>/", {"GET"}),
            ("/tools/<tool_name>/<path:filename>", {"GET"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return

        # 旧実装互換: project_root/tool/<tool_name> を探索（将来 mounts へ置換）
        project_root = Path.cwd()
        tool_root = project_root / "tool"

        def _safe_tool_dir(tool_name: str) -> Path:
            # 単純なサニタイズ（パストラバーサル対策）
            if not tool_name or "/" in tool_name or "\\" in tool_name or ".." in tool_name:
                raise ValueError("invalid tool_name")
            return tool_root / tool_name

        def _serve_tool_ui(tool_name: str, filename: str = "index.html"):
            try:
                tool_path = _safe_tool_dir(tool_name)
            except ValueError:
                abort(404, f"Tool '{tool_name}' not found")

            if not tool_path.exists() or not tool_path.is_dir():
                abort(404, f"Tool '{tool_name}' not found")

            file_path = tool_path / filename

            if not file_path.exists() and filename != "index.html":
                file_path = tool_path / "index.html"

            if not file_path.exists():
                abort(404, f"File '{filename}' not found in tool '{tool_name}'")

            mime_type, _ = mimetypes.guess_type(str(file_path))

            # HTMLは TOOL_CONFIG を注入（旧実装互換）
            if mime_type == "text/html" or filename.endswith(".html"):
                html_content = file_path.read_text(encoding="utf-8")

                tool_data = {
                    "tool_name": tool_name,
                    "tool_status": "ready",
                    "websocket_url": f"ws://localhost:5000/tools/{tool_name}/ws",
                    "api_url": f"/api/tools/{tool_name}",
                }

                inject_script = f"""
        <script>
            window.TOOL_CONFIG = {json.dumps(tool_data, ensure_ascii=False)};
        </script>
        """

                if "</head>" in html_content:
                    html_content = html_content.replace("</head>", inject_script + "</head>")
                else:
                    html_content = inject_script + html_content

                return html_content, 200, {"Content-Type": "text/html; charset=utf-8"}

            return send_from_directory(str(tool_path), file_path.name)

        # /tools/<tool_name>/  （末尾スラッシュ版）
        if any(rule == "/tools/<tool_name>/" for rule, _ in missing):
            def _tools_root(tool_name: str):
                return _serve_tool_ui(tool_name, "index.html")

            app.add_url_rule(
                "/tools/<tool_name>/",
                endpoint="rumi_io_http_tool_ui_host_v1.tools_root",
                view_func=_tools_root,
                methods=["GET"],
            )

        # /tools/<tool_name>/<path:filename>
        if any(rule == "/tools/<tool_name>/<path:filename>" for rule, _ in missing):
            def _tools_file(tool_name: str, filename: str):
                return _serve_tool_ui(tool_name, filename)

            app.add_url_rule(
                "/tools/<tool_name>/<path:filename>",
                endpoint="rumi_io_http_tool_ui_host_v1.tools_file",
                view_func=_tools_file,
                methods=["GET"],
            )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_tool_ui_host_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_tool_ui_host.register",
            handler="io_http_tool_ui_host:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/tools/<tool_name>/", "/tools/<tool_name>/<path:filename>"],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 16-B（新規）: tools WebSocket（flask-sock があれば）コンポーネント追加
新規: ecosystem/default/backend/components/io_ws_tools/manifest.json
Copy{
  "type": "io",
  "id": "io_ws_tools_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Tools WebSocket: /tools/<tool_name>/ws を提供（flask-sock がある場合のみ）"
  }
}
新規: ecosystem/default/backend/components/io_ws_tools/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set


_STATE: Dict[str, Any] = {
    "sock": None,
    "ws_registered": False,
}


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_ws_tools.register",
                handler="io_ws_tools:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        # すでに登録済みなら何もしない（idempotent）
        if _STATE.get("ws_registered"):
            return

        # flask-sock が無ければ fail-soft で何もしない
        try:
            from flask_sock import Sock
        except Exception:
            return

        # ルート衝突回避（段階移行中、app.py に残っていても落ちない）
        def _route_exists(rule: str) -> bool:
            try:
                for r in app.url_map.iter_rules():
                    if str(r.rule) == rule:
                        return True
                return False
            except Exception:
                return False

        ws_rule = "/tools/<tool_name>/ws"
        if _route_exists(ws_rule):
            return

        # Sock は app に対して1回だけ生成
        sock = _STATE.get("sock")
        if sock is None:
            sock = Sock(app)
            _STATE["sock"] = sock

        # tool_loader を得る（暫定：app.py の ai_manager を参照）
        def _get_ai_manager():
            try:
                import app as app_module  # type: ignore
                return getattr(app_module, "ai_manager", None)
            except Exception:
                return None

        @sock.route("/tools/<tool_name>/ws")
        def tool_websocket(ws, tool_name: str):
            ai = _get_ai_manager()
            if ai and getattr(ai, "tool_loader", None) and tool_name in ai.tool_loader.loaded_tools:
                tool_info = ai.tool_loader.loaded_tools[tool_name]
                module = tool_info.get("module")

                if module and hasattr(module, "websocket_handler"):
                    module.websocket_handler(ws)
                    return

            # デフォルトのエコーハンドラー（旧実装互換）
            while True:
                message = ws.receive()
                if message:
                    ws.send(f"Echo from {tool_name}: {message}")
                else:
                    break

        _STATE["ws_registered"] = True

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_ws_tools_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_ws_tools.register",
            handler="io_ws_tools:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/tools/<tool_name>/ws"],
                "note": "Requires flask-sock; otherwise no-op (fail-soft)."
            },
        )
Step 16-C（既存修正）: app.py から静的配信ルートとWebSocketブロックを削除
修正: app.py
1) ツールUI配信ルート（serve_tool_ui）を削除
削除：以下のブロック全体（2つのデコレータ＋関数）

Copy# ツールUI配信ルート
@app.route('/tools/<tool_name>/')
@app.route('/tools/<tool_name>/<path:filename>')
def serve_tool_ui(tool_name, filename='index.html'):
    """ツールのUIファイルを配信"""
    tool_path = Path('tool') / tool_name
    
    # セキュリティチェック
    if not tool_path.exists() or not tool_path.is_dir():
        abort(404, f"Tool '{tool_name}' not found")
    
    # HTMLファイルのパスを確認
    file_path = tool_path / filename
    
    # ファイルが存在しない場合、index.htmlを試す
    if not file_path.exists() and filename != 'index.html':
        file_path = tool_path / 'index.html'
    
    if not file_path.exists():
        abort(404, f"File '{filename}' not found in tool '{tool_name}'")
    
    # MIMEタイプを判定
    mime_type, _ = mimetypes.guess_type(str(file_path))
    
    # HTMLファイルの場合、動的にツールデータを注入
    if mime_type == 'text/html' or filename.endswith('.html'):
        with open(file_path, 'r', encoding='utf-8') as f:
            html_content = f.read()
        
        # ツールのステータスやデータを注入
        tool_data = {
            'tool_name': tool_name,
            'tool_status': 'ready',
            'websocket_url': f'ws://localhost:5000/tools/{tool_name}/ws',
            'api_url': f'/api/tools/{tool_name}'
        }
        
        # HTMLに埋め込むスクリプトを追加
        inject_script = f"""
        <script>
            window.TOOL_CONFIG = {json.dumps(tool_data)};
        </script>
        """
        
        # </head>タグの前にスクリプトを注入
        if '</head>' in html_content:
            html_content = html_content.replace('</head>', inject_script + '</head>')
        else:
            html_content = inject_script + html_content
        
        return html_content, 200, {'Content-Type': 'text/html; charset=utf-8'}
    
    # その他のファイル（CSS、JS、画像など）はそのまま配信
    return send_from_directory(str(tool_path), filename)
2) WebSocket対応（flask-sock）ブロックを削除
削除：以下の try: ... except ImportError: ... ブロック全体

Copy# WebSocket対応（オプション - flask-sockが必要）
try:
    from flask_sock import Sock
    sock = Sock(app)
    
    @sock.route('/tools/<tool_name>/ws')
    def tool_websocket(ws, tool_name):
        """ツール用WebSocket接続"""
        if ai_manager and tool_name in ai_manager.tool_loader.loaded_tools:
            tool_info = ai_manager.tool_loader.loaded_tools[tool_name]
            module = tool_info.get('module')
            
            # ツールにwebsocket_handler関数があれば呼び出し
            if hasattr(module, 'websocket_handler'):
                module.websocket_handler(ws)
            else:
                # デフォルトのエコーハンドラー
                while True:
                    message = ws.receive()
                    if message:
                        ws.send(f"Echo from {tool_name}: {message}")
                    else:
                        break
except ImportError:
    print("flask-sock not installed. WebSocket support disabled.")

Step 17-A（新規）: runtime サービスコンポーネント追加
新規: ecosystem/default/backend/components/runtime_services/manifest.json
Copy{
  "type": "runtime",
  "id": "runtime_services_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["runtime.get_ai_manager", "runtime.get_tool_ui_manager", "runtime.get_supporter_dependency_manager"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "IOコンポーネント向けに runtime サービス（ai_manager等）を InterfaceRegistry で提供する（公式app.pyへの依存を排除）"
  }
}
新規: ecosystem/default/backend/components/runtime_services/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional
import traceback


_STATE: Dict[str, Any] = {
    "ai_manager": None,
    "ai_manager_init_attempted": False,
    "ai_manager_init_error": None,

    "tool_ui_manager": None,

    "supporter_dependency_manager": None,
    "supporter_dep_init_attempted": False,
    "supporter_dep_init_error": None,
}


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="runtime_services.register",
                handler="runtime_services:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def get_ai_manager() -> Any:
        """
        ai_manager.AIClient を singleton として返す（fail-soft）。
        """
        if _STATE["ai_manager"] is not None:
            return _STATE["ai_manager"]
        if _STATE["ai_manager_init_attempted"]:
            return None

        _STATE["ai_manager_init_attempted"] = True
        try:
            from ai_manager import AIClient  # legacy root module (移行中)
            _STATE["ai_manager"] = AIClient()
            _STATE["ai_manager_init_error"] = None
            return _STATE["ai_manager"]
        except Exception as e:
            _STATE["ai_manager_init_error"] = f"{type(e).__name__}: {e}"
            if diagnostics:
                diagnostics.record_step(
                    phase="startup",
                    step_id="runtime_services.ai_manager_init",
                    handler="runtime_services:get_ai_manager",
                    status="failed",
                    error={"type": type(e).__name__, "message": str(e), "trace": traceback.format_exc()[-4000:]},
                    meta={},
                )
            return None

    def get_tool_ui_manager() -> Any:
        """
        tool_ui_manager.tool_ui_manager を返す（singleton）。
        """
        if _STATE["tool_ui_manager"] is not None:
            return _STATE["tool_ui_manager"]
        try:
            from tool_ui_manager import tool_ui_manager  # legacy root module
            _STATE["tool_ui_manager"] = tool_ui_manager
            return tool_ui_manager
        except Exception:
            # fail-soft: どうしても無ければ None
            return None

    def get_supporter_dependency_manager() -> Any:
        """
        supporter dependency manager を返す（存在しない環境でもfail-soft）。
        現状の legacy import パスに依存（後で supporter サービスとして独立させる）。
        """
        if _STATE["supporter_dependency_manager"] is not None:
            return _STATE["supporter_dependency_manager"]
        if _STATE["supporter_dep_init_attempted"]:
            return None

        _STATE["supporter_dep_init_attempted"] = True
        try:
            from ecosystem.default.backend.components.supporter.supporter_dependency_manager import SupporterDependencyManager  # legacy path
            _STATE["supporter_dependency_manager"] = SupporterDependencyManager()
            _STATE["supporter_dep_init_error"] = None
            return _STATE["supporter_dependency_manager"]
        except Exception as e:
            _STATE["supporter_dep_init_error"] = f"{type(e).__name__}: {e}"
            return None

    interface_registry.register("runtime.get_ai_manager", get_ai_manager, meta={"component": "runtime_services_v1"})
    interface_registry.register("runtime.get_tool_ui_manager", get_tool_ui_manager, meta={"component": "runtime_services_v1"})
    interface_registry.register("runtime.get_supporter_dependency_manager", get_supporter_dependency_manager, meta={"component": "runtime_services_v1"})

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="runtime_services.register",
            handler="runtime_services:setup",
            status="success",
            meta={"registered": ["runtime.get_ai_manager", "runtime.get_tool_ui_manager", "runtime.get_supporter_dependency_manager"]},
        )
Step 17-B（既存修正）: import app 依存を削除（各 component の修正部分のみ）
1) 修正: ecosystem/default/backend/components/io_http_tools_api/setup.py
置換1：_ensure_runtime() と _get_ai_manager/_get_tool_ui_manager 周辺
（import app as app_module を使っている部分を置き換え）

Copy# --- 修正箇所: io_http_tools_api/setup.py 内 bind_http() の _ensure_runtime/_get_ai_manager/_get_tool_ui_manager を置換 ---

        def _get_runtime_getter(key: str):
            try:
                fn = kernel.interface_registry.get(key, strategy="last")
                return fn if callable(fn) else None
            except Exception:
                return None

        def _get_ai_manager():
            getter = _get_runtime_getter("runtime.get_ai_manager")
            if getter:
                return getter()
            # fallback（公式app.pyに依存しない）
            try:
                from ai_manager import AIClient
                if _STATE.get("ai_manager") is None:
                    _STATE["ai_manager"] = AIClient()
                return _STATE["ai_manager"]
            except Exception:
                return None

        def _get_tool_ui_manager():
            getter = _get_runtime_getter("runtime.get_tool_ui_manager")
            if getter:
                return getter()
            # fallback（公式app.pyに依存しない）
            try:
                from tool_ui_manager import tool_ui_manager as tum
                return tum
            except Exception:
                return None
これで io_http_tools_api は app を一切 import しません。

置換2：/api/test/tool_execution で import app していた chat_manager 参照の撤去
（chat_manager を app から取るのをやめ、直接生成）

Copy# --- 修正箇所: io_http_tools_api/setup.py 内 _test_tool_execution の chat_manager 取得部分を置換 ---

                # chat_manager は直接生成（app.py参照を排除）
                try:
                    from chat_manager import ChatManager
                    chat_manager = ChatManager()
                except Exception:
                    chat_manager = None
2) 修正: ecosystem/default/backend/components/io_http_tool_data/setup.py
import app as app_module を使っている ai_manager 参照を、runtime getter に置換します。

Copy# --- 修正箇所: io_http_tool_data/setup.py の _ensure_ai_manager/_get_ai_manager を置換 ---

        def _get_runtime_getter(key: str):
            try:
                fn = kernel.interface_registry.get(key, strategy="last")
                return fn if callable(fn) else None
            except Exception:
                return None

        def _ensure_ai_manager():
            if _STATE["ai_manager"] is not None:
                return True
            if _STATE["init_attempted"]:
                return False
            _STATE["init_attempted"] = True

            getter = _get_runtime_getter("runtime.get_ai_manager")
            if getter:
                _STATE["ai_manager"] = getter()
                return True

            # fallback（公式app.pyに依存しない）
            try:
                from ai_manager import AIClient
                _STATE["ai_manager"] = AIClient()
                return True
            except Exception as e:
                _STATE["init_error"] = f"{type(e).__name__}: {e}"
                return False
3) 修正: ecosystem/default/backend/components/io_ws_tools/setup.py
WebSocket 側の _get_ai_manager() の import app を runtime getter に置換します。

Copy# --- 修正箇所: io_ws_tools/setup.py の _get_ai_manager() を置換 ---

        def _get_ai_manager():
            try:
                getter = kernel.interface_registry.get("runtime.get_ai_manager", strategy="last")
                if callable(getter):
                    return getter()
            except Exception:
                pass
            # fallback（公式app.pyに依存しない）
            try:
                from ai_manager import AIClient
                # ws側は毎回作ると重いので、モジュールキャッシュで1回だけ
                if not hasattr(_STATE, "_ws_ai_manager"):
                    _STATE["_ws_ai_manager"] = AIClient()
                return _STATE["_ws_ai_manager"]
            except Exception:
                return None
これで io_ws_tools も app を import しません。

4) 修正: ecosystem/default/backend/components/io_http_chat_tools/setup.py
この component は以前 import app で ai_manager を取っていたので、runtime getter に置換します。

Copy# --- 修正箇所: io_http_chat_tools/setup.py 内 handle_chat_tools() の ai_manager 取得を置換 ---

            # ai_manager を runtime から取得（公式 app.py 参照を排除）
            try:
                getter = kernel.interface_registry.get("runtime.get_ai_manager", strategy="last")
                ai_manager = getter() if callable(getter) else None
            except Exception:
                ai_manager = None

            # fallback（公式app.pyに依存しない）
            if ai_manager is None:
                try:
                    from ai_manager import AIClient
                    ai_manager = AIClient()
                except Exception:
                    ai_manager = None
5) 修正: ecosystem/default/backend/components/io_http_supporters/setup.py
dependency manager の取得が app 依存だったので、runtime getter に置換します（SupporterLoaderは引き続き legacy import を使うのでここは最小変更）。

Copy# --- 修正箇所: io_http_supporters/setup.py 内 _get_dependency_manager() を置換 ---

        def _get_dependency_manager():
            if _STATE["dependency_manager"] is not None:
                return _STATE["dependency_manager"]
            if _STATE["dependency_manager_init_attempted"]:
                return None

            _STATE["dependency_manager_init_attempted"] = True

            # runtime から取得
            try:
                getter = kernel.interface_registry.get("runtime.get_supporter_dependency_manager", strategy="last")
                if callable(getter):
                    dm = getter()
                    if dm is not None:
                        _STATE["dependency_manager"] = dm
                        return dm
            except Exception:
                pass

            _STATE["dependency_manager_init_error"] = "Dependency manager not available"
            return None
修正: app.py
1) legacy ai_manager 初期化ブロックを削除
削除：このブロック全体

Copy# ai_managerを先に初期化
from ai_manager import AIClient

try:
    # ai_managerを初期化（APIキーチェックは各クライアントが行う）
    ai_manager = AIClient()
except ValueError as e:
    print(f"致命的なエラー: {e}")
    ai_manager = None
2) legacy マネージャ import/初期化から SettingsManager / tool_ui_manager / RelationshipManager を削除
まず import 群から以下を削除してください（該当行のみ削除）。

削除対象 import 行：

Copyfrom settings_manager import SettingsManager
from tool_ui_manager import tool_ui_manager
from relationship_manager import RelationshipManager
※ すでに Step15 で ChatManager / MessageHandler / RelationshipManager の import を削除している場合は、重複削除不要です。

次に、初期化ブロックから以下を削除してください（該当行のみ削除）。

削除対象：

Copysettings_manager = SettingsManager()
relationship_manager = RelationshipManager()
3) __main__ の debug logging 適用（ai_manager依存）を削除
削除：このブロック全体（または中身を空に）

Copy    # デバッグログ設定を適用
    if ai_manager:
        settings = settings_manager.get_user_settings()
        if settings.get('debug_logging', False):
            ai_manager.set_debug_logging(True)
/api/debug/logging は ecosystem に移したので、起動時にここで触る必要はなくなります。

4) atexit cleanup を runtime 経由に変更（tool_ui_manager グローバル参照を撤去）
現状の cleanup を 置き換えます。

変更前（例：あなたの現行）
Copydef cleanup():
    """アプリケーション終了時のクリーンアップ"""
    print("Cleaning up UI servers...")
    tool_ui_manager.stop_all_ui_servers()
変更後（置換）
Copydef cleanup():
    """アプリケーション終了時のクリーンアップ（fail-soft）"""
    print("Cleaning up UI servers...")
    try:
        # まず Kernel 経由で runtime サービスを取りに行く（推奨）
        if _kernel is not None:
            getter = _kernel.interface_registry.get("runtime.get_tool_ui_manager", strategy="last")
            if callable(getter):
                tum = getter()
                if tum and hasattr(tum, "stop_all_ui_servers"):
                    tum.stop_all_ui_servers()
                    return
        # fallback: 直接 import（移行中の保険）
        from tool_ui_manager import tool_ui_manager as tum2
        tum2.stop_all_ui_servers()
    except Exception as e:
        print(f"[cleanup] fail-soft: {e}")
Step 19-A（新規）: ecosystem 管理APIコンポーネント追加
新規: ecosystem/default/backend/components/io_http_ecosystem_admin/manifest.json
Copy{
  "type": "io",
  "id": "io_http_ecosystem_admin_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["io.http.binders"],
    "requires": []
  },
  "addon_policy": {
    "deny_all": false,
    "allowed_manifest_paths": ["/extensions"],
    "editable_files": []
  },
  "metadata": {
    "description": "Kernel diagnostics と Ecosystem 管理API（/api/kernel/diagnostics, /api/ecosystem/*）を提供"
  }
}
新規: ecosystem/default/backend/components/io_http_ecosystem_admin/setup.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set


def run(context: Dict[str, Any]) -> None:
    interface_registry = context.get("interface_registry")
    diagnostics = context.get("diagnostics")

    if interface_registry is None:
        if diagnostics:
            diagnostics.record_step(
                phase="startup",
                step_id="io_http_ecosystem_admin.register",
                handler="io_http_ecosystem_admin:setup",
                status="skipped",
                meta={"reason": "missing_interface_registry"},
            )
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify

        def _route_exists(rule: str, methods: Optional[Set[str]] = None) -> bool:
            try:
                want = set(m.upper() for m in (methods or set()))
                for r in app.url_map.iter_rules():
                    if str(r.rule) != rule:
                        continue
                    if want:
                        existing = set(m.upper() for m in (r.methods or set()))
                        if not want.issubset(existing):
                            continue
                    return True
                return False
            except Exception:
                return False

        needed = [
            ("/api/kernel/diagnostics", {"GET"}),

            ("/api/ecosystem/status", {"GET"}),
            ("/api/ecosystem/packs", {"GET"}),
            ("/api/ecosystem/components", {"GET"}),
            ("/api/ecosystem/addons", {"GET"}),
            ("/api/ecosystem/overrides", {"GET", "POST"}),
            ("/api/ecosystem/reload", {"POST"}),
        ]
        missing = [(rule, methods) for rule, methods in needed if not _route_exists(rule, methods)]
        if not missing:
            return

        # -------------------------
        # /api/kernel/diagnostics
        # -------------------------
        if any(rule == "/api/kernel/diagnostics" for rule, _ in missing):
            def _kernel_diagnostics():
                # WSGI middlewareで kernel は既に起動済み想定だが、fail-softで返す
                try:
                    return jsonify({
                        "initialized": True,
                        "diagnostics": kernel.diagnostics.as_dict(),
                    }), 200
                except Exception as e:
                    return jsonify({
                        "initialized": True,
                        "error": str(e),
                        "diagnostics": None,
                    }), 200

            app.add_url_rule(
                "/api/kernel/diagnostics",
                endpoint="rumi_io_http_ecosystem_admin_v1.kernel_diagnostics",
                view_func=_kernel_diagnostics,
                methods=["GET"],
            )

        # -------------------------
        # Ecosystem helpers
        # -------------------------
        def _is_initialized() -> bool:
            try:
                from backend_core.ecosystem.compat import is_ecosystem_initialized
                return bool(is_ecosystem_initialized())
            except Exception:
                return False

        def _get_registry():
            from backend_core.ecosystem import get_registry
            return get_registry()

        def _get_active_manager():
            from backend_core.ecosystem import get_active_ecosystem_manager
            return get_active_ecosystem_manager()

        def _get_addon_manager():
            from backend_core.ecosystem import get_addon_manager
            return get_addon_manager()

        # -------------------------
        # /api/ecosystem/status
        # -------------------------
        if any(rule == "/api/ecosystem/status" for rule, _ in missing):
            def _ecosystem_status():
                try:
                    if not _is_initialized():
                        return jsonify({
                            "initialized": False,
                            "message": "エコシステムは初期化されていません"
                        })

                    reg = _get_registry()
                    active = _get_active_manager()

                    return jsonify({
                        "initialized": True,
                        "active_pack_identity": active.active_pack_identity,
                        "packs": list(reg.packs.keys()),
                        "total_components": len(reg.get_all_components()),
                        "overrides": active.get_all_overrides()
                    })
                except ImportError:
                    return jsonify({
                        "initialized": False,
                        "message": "エコシステムモジュールが利用できません"
                    })
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ecosystem/status",
                endpoint="rumi_io_http_ecosystem_admin_v1.ecosystem_status",
                view_func=_ecosystem_status,
                methods=["GET"],
            )

        # -------------------------
        # /api/ecosystem/packs
        # -------------------------
        if any(rule == "/api/ecosystem/packs" for rule, _ in missing):
            def _ecosystem_packs():
                try:
                    if not _is_initialized():
                        return jsonify({"error": "Ecosystem not initialized"}), 500

                    reg = _get_registry()
                    packs = []
                    for pack_id, pack_info in reg.packs.items():
                        packs.append({
                            "pack_id": pack_id,
                            "pack_identity": pack_info.pack_identity,
                            "version": pack_info.version,
                            "uuid": pack_info.uuid,
                            "components_count": len(pack_info.components),
                            "addons_count": len(pack_info.addons),
                        })

                    return jsonify({"success": True, "packs": packs})
                except ImportError:
                    return jsonify({"error": "Ecosystem module not available"}), 500
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ecosystem/packs",
                endpoint="rumi_io_http_ecosystem_admin_v1.ecosystem_packs",
                view_func=_ecosystem_packs,
                methods=["GET"],
            )

        # -------------------------
        # /api/ecosystem/components
        # -------------------------
        if any(rule == "/api/ecosystem/components" for rule, _ in missing):
            def _ecosystem_components():
                try:
                    if not _is_initialized():
                        return jsonify({"error": "Ecosystem not initialized"}), 500

                    reg = _get_registry()
                    components = []
                    for component in reg.get_all_components():
                        components.append({
                            "type": component.type,
                            "id": component.id,
                            "version": component.version,
                            "uuid": component.uuid,
                            "pack_id": component.pack_id,
                            "full_id": component.full_id,
                        })

                    return jsonify({"success": True, "components": components})
                except ImportError:
                    return jsonify({"error": "Ecosystem module not available"}), 500
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ecosystem/components",
                endpoint="rumi_io_http_ecosystem_admin_v1.ecosystem_components",
                view_func=_ecosystem_components,
                methods=["GET"],
            )

        # -------------------------
        # /api/ecosystem/addons
        # -------------------------
        if any(rule == "/api/ecosystem/addons" for rule, _ in missing):
            def _ecosystem_addons():
                try:
                    if not _is_initialized():
                        return jsonify({"error": "Ecosystem not initialized"}), 500

                    am = _get_addon_manager()
                    addons = []
                    for addon in am.get_all_addons():
                        addons.append({
                            "addon_id": addon.addon_id,
                            "version": addon.version,
                            "priority": addon.priority,
                            "enabled": addon.enabled,
                            "pack_id": addon.pack_id,
                            "full_id": addon.full_id,
                        })

                    return jsonify({"success": True, "addons": addons})
                except ImportError:
                    return jsonify({"error": "Ecosystem module not available"}), 500
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ecosystem/addons",
                endpoint="rumi_io_http_ecosystem_admin_v1.ecosystem_addons",
                view_func=_ecosystem_addons,
                methods=["GET"],
            )

        # -------------------------
        # /api/ecosystem/overrides (GET/POST)
        # -------------------------
        if any(rule == "/api/ecosystem/overrides" for rule, _ in missing):
            def _ecosystem_overrides():
                try:
                    if not _is_initialized():
                        return jsonify({"error": "Ecosystem not initialized"}), 500

                    manager = _get_active_manager()

                    if request.method == "GET":
                        return jsonify({"success": True, "overrides": manager.get_all_overrides()})

                    data = request.get_json(silent=True) or {}
                    component_type = data.get("component_type")
                    component_id = data.get("component_id")

                    if not component_type or not component_id:
                        return jsonify({"error": "component_type and component_id are required"}), 400

                    manager.set_override(component_type, component_id)
                    return jsonify({"success": True, "message": f"{component_type} を {component_id} に設定しました"})
                except ImportError:
                    return jsonify({"error": "Ecosystem module not available"}), 500
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ecosystem/overrides",
                endpoint="rumi_io_http_ecosystem_admin_v1.ecosystem_overrides",
                view_func=_ecosystem_overrides,
                methods=["GET", "POST"],
            )

        # -------------------------
        # /api/ecosystem/reload (POST)
        # -------------------------
        if any(rule == "/api/ecosystem/reload" for rule, _ in missing):
            def _reload_ecosystem():
                try:
                    if not _is_initialized():
                        return jsonify({"error": "Ecosystem not initialized"}), 500

                    from backend_core.ecosystem import reload_registry, reload_addon_manager
                    reg = reload_registry()
                    am = reload_addon_manager()

                    # アドオンを再読み込み
                    for pack in reg.packs.values():
                        am.load_addons_from_pack(pack)

                    return jsonify({
                        "success": True,
                        "packs_loaded": len(reg.packs),
                        "components_loaded": len(reg.get_all_components()),
                        "addons_loaded": len(am.get_all_addons())
                    })
                except ImportError:
                    return jsonify({"error": "Ecosystem module not available"}), 500
                except Exception as e:
                    return jsonify({"error": str(e)}), 500

            app.add_url_rule(
                "/api/ecosystem/reload",
                endpoint="rumi_io_http_ecosystem_admin_v1.ecosystem_reload",
                view_func=_reload_ecosystem,
                methods=["POST"],
            )

    interface_registry.register(
        "io.http.binders",
        bind_http,
        meta={"component": "io_http_ecosystem_admin_v1", "kind": "binder"},
    )

    if diagnostics:
        diagnostics.record_step(
            phase="startup",
            step_id="io_http_ecosystem_admin.register",
            handler="io_http_ecosystem_admin:setup",
            status="success",
            meta={
                "registered": ["io.http.binders"],
                "routes": ["/api/kernel/diagnostics", "/api/ecosystem/*"],
                "conflict_policy": "per-route selective registration (migration-safe)"
            },
        )
Step 19-B（既存修正）: app.py から該当エンドポイントを削除（ピンポイント）
以下のブロックを app.py から削除してください（完全一致で、その関数ブロック全体）。

修正: app.py
1) /api/ecosystem/status
削除：

Copy@app.route('/api/ecosystem/status', methods=['GET'])
def get_ecosystem_status():
    """エコシステムのステータスを取得"""
    try:
        from backend_core.ecosystem.compat import is_ecosystem_initialized
        from backend_core.ecosystem import get_registry, get_active_ecosystem_manager
        
        if not is_ecosystem_initialized():
            return jsonify({
                'initialized': False,
                'message': 'エコシステムは初期化されていません'
            })
        
        registry = get_registry()
        active_manager = get_active_ecosystem_manager()
        
        return jsonify({
            'initialized': True,
            'active_pack_identity': active_manager.active_pack_identity,
            'packs': list(registry.packs.keys()),
            'total_components': len(registry.get_all_components()),
            'overrides': active_manager.get_all_overrides()
        })
    except ImportError:
        return jsonify({
            'initialized': False,
            'message': 'エコシステムモジュールが利用できません'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500
2) /api/ecosystem/packs
削除：

Copy@app.route('/api/ecosystem/packs', methods=['GET'])
def get_ecosystem_packs():
    """利用可能なPackの一覧を取得"""
    try:
        from backend_core.ecosystem.compat import is_ecosystem_initialized
        from backend_core.ecosystem import get_registry
        
        if not is_ecosystem_initialized():
            return jsonify({'error': 'Ecosystem not initialized'}), 500
        
        registry = get_registry()
        packs = []
        
        for pack_id, pack_info in registry.packs.items():
            packs.append({
                'pack_id': pack_id,
                'pack_identity': pack_info.pack_identity,
                'version': pack_info.version,
                'uuid': pack_info.uuid,
                'components_count': len(pack_info.components),
                'addons_count': len(pack_info.addons)
            })
        
        return jsonify({
            'success': True,
            'packs': packs
        })
    except ImportError:
        return jsonify({'error': 'Ecosystem module not available'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500
3) /api/ecosystem/components
削除：

Copy@app.route('/api/ecosystem/components', methods=['GET'])
def get_ecosystem_components():
    """利用可能なComponentの一覧を取得"""
    try:
        from backend_core.ecosystem.compat import is_ecosystem_initialized
        from backend_core.ecosystem import get_registry
        
        if not is_ecosystem_initialized():
            return jsonify({'error': 'Ecosystem not initialized'}), 500
        
        registry = get_registry()
        components = []
        
        for component in registry.get_all_components():
            components.append({
                'type': component.type,
                'id': component.id,
                'version': component.version,
                'uuid': component.uuid,
                'pack_id': component.pack_id,
                'full_id': component.full_id
            })
        
        return jsonify({
            'success': True,
            'components': components
        })
    except ImportError:
        return jsonify({'error': 'Ecosystem module not available'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500
4) /api/ecosystem/addons
削除：

Copy@app.route('/api/ecosystem/addons', methods=['GET'])
def get_ecosystem_addons():
    """利用可能なAddonの一覧を取得"""
    try:
        from backend_core.ecosystem.compat import is_ecosystem_initialized
        from backend_core.ecosystem import get_addon_manager
        
        if not is_ecosystem_initialized():
            return jsonify({'error': 'Ecosystem not initialized'}), 500
        
        addon_manager = get_addon_manager()
        addons = []
        
        for addon in addon_manager.get_all_addons():
            addons.append({
                'addon_id': addon.addon_id,
                'version': addon.version,
                'priority': addon.priority,
                'enabled': addon.enabled,
                'pack_id': addon.pack_id,
                'full_id': addon.full_id
            })
        
        return jsonify({
            'success': True,
            'addons': addons
        })
    except ImportError:
        return jsonify({'error': 'Ecosystem module not available'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500
5) /api/ecosystem/overrides
削除：

Copy@app.route('/api/ecosystem/overrides', methods=['GET', 'POST'])
def handle_ecosystem_overrides():
    """コンポーネントオーバーライドの取得/設定"""
    try:
        from backend_core.ecosystem.compat import is_ecosystem_initialized
        from backend_core.ecosystem import get_active_ecosystem_manager
        
        if not is_ecosystem_initialized():
            return jsonify({'error': 'Ecosystem not initialized'}), 500
        
        manager = get_active_ecosystem_manager()
        
        if request.method == 'GET':
            return jsonify({
                'success': True,
                'overrides': manager.get_all_overrides()
            })
        
        elif request.method == 'POST':
            data = request.json
            component_type = data.get('component_type')
            component_id = data.get('component_id')
            
            if not component_type or not component_id:
                return jsonify({'error': 'component_type and component_id are required'}), 400
            
            manager.set_override(component_type, component_id)
            
            return jsonify({
                'success': True,
                'message': f'{component_type} を {component_id} に設定しました'
            })
    except ImportError:
        return jsonify({'error': 'Ecosystem module not available'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500
6) /api/ecosystem/reload
削除：

Copy@app.route('/api/ecosystem/reload', methods=['POST'])
def reload_ecosystem():
    """エコシステムを再読み込み"""
    try:
        from backend_core.ecosystem import reload_registry, reload_addon_manager
        from backend_core.ecosystem.compat import is_ecosystem_initialized
        
        if not is_ecosystem_initialized():
            return jsonify({'error': 'Ecosystem not initialized'}), 500
        
        registry = reload_registry()
        addon_manager = reload_addon_manager()
        
        # アドオンを再読み込み
        for pack in registry.packs.values():
            addon_manager.load_addons_from_pack(pack)
        
        return jsonify({
            'success': True,
            'packs_loaded': len(registry.packs),
            'components_loaded': len(registry.get_all_components()),
            'addons_loaded': len(addon_manager.get_all_addons())
        })
    except ImportError:
        return jsonify({'error': 'Ecosystem module not available'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500
7) /api/kernel/diagnostics
削除：

Copy@app.route('/api/kernel/diagnostics', methods=['GET'])
def get_kernel_diagnostics():
    """
    Kernel（Flow駆動OS）の診断情報を返す。
    fail-soft のため、Kernelが初期化できない場合でもAPI自体は動作する。
    """
    # diagnostics取得前に一度だけ起動を試みる（fail-soft）
    ensure_kernel_started()
    ensure_kernel_interfaces_registered()
    
    if _kernel is None:
        return jsonify({
            'initialized': False,
            'error': 'Kernel not initialized (startup failed or disabled)',
            'diagnostics': None
        }), 200
    try:
        return jsonify({
            'initialized': True,
            'started': _kernel_started,
            'start_error': _kernel_start_error,
            'diagnostics': _kernel.diagnostics.as_dict()
        }), 200
    except Exception as e:
        return jsonify({
            'initialized': True,
            'started': _kernel_started,
            'start_error': _kernel_start_error,
            'error': str(e),
            'diagnostics': None
        }), 200
修正: app.py
1) import 時の ecosystem 初期化ブロックを削除（完全削除）
削除対象：この try/except ブロック全体

Copy# エコシステム初期化（他のマネージャーより先に実行）
try:
    from backend_core.ecosystem import initialize_ecosystem
    from backend_core.ecosystem.compat import mark_ecosystem_initialized
    
    init_result = initialize_ecosystem()
    if init_result['success']:
        mark_ecosystem_initialized()
        print(f"エコシステム初期化成功: {init_result['packs_loaded']}個のPack, {init_result['components_loaded']}個のComponent")
    else:
        print(f"エコシステム初期化に問題があります: {init_result['errors']}")
except ImportError as e:
    print(f"エコシステムモジュールが見つかりません（従来モードで動作）: {e}")
except Exception as e:
    print(f"エコシステム初期化エラー（従来モードで動作）: {e}")
    import traceback
    traceback.print_exc()
2) （確認）Kernel起動後の compat refresh は残してOK（現状維持）
ensure_kernel_started() 内にある以下の部分は 残してください（Kernelが registry/active/mounts を確定させた後に compat を追随させるため）。
※将来これは Kernel handler 側に寄せて app.py から消します。

Copy            try:
                from backend_core.ecosystem.compat import mark_ecosystem_initialized
                mark_ecosystem_initialized()
            except Exception as e:
                print(f"[Kernel] compat sys.path refresh failed (fail-soft): {e}")
1) 既存ファイルの修正（修正部分のみ）
1-1. core_runtime/component_lifecycle.py：runtime_boot フェーズを実装
修正点A：run_phase() が runtime_boot を扱えるようにする
Copy# --- 修正箇所: core_runtime/component_lifecycle.py ---

def run_phase(self, phase_name: str) -> Dict[str, Any]:
    """
    フェーズ実行:
    - dependency: dependency_manager.py
    - setup: setup.py
    - runtime_boot: runtime_boot.py  ← 追加（interface登録など）
    """
    phase = (phase_name or "").strip()
    if phase not in ("dependency", "setup", "runtime_boot"):
        ...
修正点B：_run_phase_for_component() のファイル選択を追加
Copy# --- 修正箇所: core_runtime/component_lifecycle.py ---

def _run_phase_for_component(self, phase: str, component: Any) -> None:
    ...
    if phase == "dependency":
        filename = "dependency_manager.py"
    elif phase == "setup":
        filename = "setup.py"
    else:  # runtime_boot
        filename = "runtime_boot.py"
    file_path = runtime_dir / filename
    ...
1-2. flow/project.flow.yaml：startup に runtime_boot を追加（置換でOK）
※既存ファイルなので「差分」としては、pipelines.startup に1ステップ追加です。

Copy// --- 修正箇所: flow/project.flow.yaml の pipelines.startup に追加 ---
{
  "id": "startup.runtime_boot",
  "run": { "handler": "component_phase:runtime_boot", "args": {} },
  "optional": true,
  "on_error": { "action": "continue" }
}
（位置は startup.setup の直後が推奨）

1-3. app.py：公式を最小ランナー化（APIルート全撤去）
あなたの「既存は修正部分のみ」ルールに従い、削除・残す範囲を明確化します。

app.pyで「残す」もの
app = Flask(__name__)
Kernel遅延起動（ensure_kernel_started）
binder適用（ensure_http_binders_applied）
WSGIミドルウェアで「ルーティング前にstartup+bind」
UI用の @app.route('/') と @app.route('/chats/<chat_id>')
if __name__ == '__main__': app.run(...)
app.pyで「削除」するもの（全部）
@app.route('/api/...') で始まる 全APIエンドポイント
prompt/ai/tool/supporter関連の import/初期化/ルート
ecosystem管理API（/api/ecosystem/*）や kernel diagnostics API も削除（io_http_apiへ集約）
これにより「公式のAPI重複」事故が構造的に消えます。

2) 新規ファイル（全文）
ここからが “一括で整う本体” です。prompt/ai/tool を一切参照しません。

2-1. foundation（ルート登録の共通部品：コピペ根絶）
ecosystem/default/backend/components/foundation/manifest.json
Copy{
  "type": "foundation",
  "id": "foundation_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["foundation.http.routes"], "requires": [] },
  "metadata": { "description": "IO/Service共通の基盤（safe_add_url_rule等）" }
}
ecosystem/default/backend/components/foundation/runtime_boot.py
Copyfrom __future__ import annotations
from typing import Any, Dict

def run(context: Dict[str, Any]) -> None:
    # foundationは import 用なので registry 登録不要でも良いが、
    # “存在確認”のために1つ登録しておく（贔屓なし、ただの目印）
    ir = context.get("interface_registry")
    if ir:
        ir.register("foundation.http.routes", {"version": "1.0"}, meta={"component": "foundation_v1"})
ecosystem/default/backend/components/foundation/rumi_foundation/http/routes.py
Copyfrom __future__ import annotations
from typing import Callable, Optional, Set, Any

def route_exists(app, rule: str, methods: Optional[Set[str]] = None) -> bool:
    want = set(m.upper() for m in (methods or set()))
    for r in app.url_map.iter_rules():
        if str(r.rule) != rule:
            continue
        if want:
            existing = set(m.upper() for m in (r.methods or set()))
            if not want.issubset(existing):
                continue
        return True
    return False

def safe_add_url_rule(app, rule: str, endpoint: str, view_func: Callable[..., Any], methods: Set[str]) -> bool:
    """
    ルート単位の安全登録（段階移行に強い）
    - 既に同一 rule+methods が存在するなら何もしない
    - endpoint衝突は “そもそも同一ruleがあればスキップ” で回避
    Returns: True if added, False if skipped
    """
    if route_exists(app, rule, methods):
        return False
    app.add_url_rule(rule, endpoint=endpoint, view_func=view_func, methods=sorted(list(methods)))
    return True
2-2. services（chats / relationships / messageスタブ）
ecosystem/default/backend/components/services_chats/manifest.json
Copy{
  "type": "service",
  "id": "services_chats_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["service.chats"], "requires": [] },
  "metadata": { "description": "Chatサービス（ChatManagerを提供）" }
}
ecosystem/default/backend/components/services_chats/runtime_boot.py
Copyfrom __future__ import annotations
from typing import Any, Dict

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return

    # 既存の ChatManager をそのままサービスとして提供（prompt/ai/tool不要）
    from chat_manager import ChatManager
    cm = ChatManager()
    ir.register("service.chats", cm, meta={"component": "services_chats_v1"})
ecosystem/default/backend/components/services_relationships/manifest.json
Copy{
  "type": "service",
  "id": "services_relationships_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["service.relationships"], "requires": [] },
  "metadata": { "description": "Relationshipサービス（RelationshipManagerを提供）" }
}
ecosystem/default/backend/components/services_relationships/runtime_boot.py
Copyfrom __future__ import annotations
from typing import Any, Dict

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return

    from relationship_manager import RelationshipManager
    rm = RelationshipManager()
    ir.register("service.relationships", rm, meta={"component": "services_relationships_v1"})
ecosystem/default/backend/components/services_message_stub/manifest.json
Copy{
  "type": "service",
  "id": "services_message_stub_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["message.handle", "message.handle_stream", "message.abort"],
    "requires": ["service.chats"]
  },
  "metadata": { "description": "AI未実装時のmessageサービス（履歴保存＋スタブ応答）" }
}
ecosystem/default/backend/components/services_message_stub/runtime_boot.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional
import threading
import time

_ABORT = threading.Event()

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    diag = context.get("diagnostics")
    if not ir:
        return

    def _get_chats_service():
        try:
            return ir.get("service.chats", strategy="last")
        except Exception:
            return None

    def _append_message(cm, chat_id: str, role: str, content: str, status: str = "completed") -> None:
        # chat_manager の標準形式ヘルパを使う（既存資産）
        from chat_manager import create_standard_message, add_message_to_history
        history = cm.load_chat_history(chat_id)
        msg = create_standard_message(
            role=role,
            content=content,
            parent_id=history.get("current_node"),
            status=status,
        )
        history = add_message_to_history(history, msg)
        cm.save_chat_history(chat_id, history)

    def message_handle(chat_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        cm = _get_chats_service()
        if cm is None:
            return {"success": False, "error": "Chat service unavailable", "chat_id": chat_id}

        user_text = ""
        try:
            msg = (payload or {}).get("message") or {}
            user_text = msg.get("text", "") if isinstance(msg, dict) else ""
        except Exception:
            user_text = ""

        if user_text.strip():
            _append_message(cm, chat_id, "user", user_text)

        # AI未実装スタブ
        reply = "AI subsystem is not installed yet. (ai_client was removed; implement ai service and register message.handle to enable.)"
        _append_message(cm, chat_id, "assistant", reply)

        return {
            "success": True,
            "response": reply,
            "metadata": {"chat_id": chat_id},
        }

    def message_handle_stream(chat_id: str, payload: Dict[str, Any]):
        from flask import Response
        cm = _get_chats_service()
        if cm is None:
            return {"success": False, "error": "Chat service unavailable", "chat_id": chat_id}

        _ABORT.clear()

        user_text = ""
        msg = (payload or {}).get("message") or {}
        if isinstance(msg, dict):
            user_text = msg.get("text", "") or ""
        if user_text.strip():
            _append_message(cm, chat_id, "user", user_text)

        reply = "AI subsystem is not installed yet. (ai_client was removed; implement ai service and register message.handle to enable.)"

        def gen():
            # SSE
            yield 'data: {"type":"chunk","text":"'
            for ch in reply:
                if _ABORT.is_set():
                    yield '"}\n\n'
                    return
                # very small chunking
                yield ch.replace('"', '\\"')
                time.sleep(0.005)
            yield '"}\n\n'
            yield 'data: {"type":"complete","full_text":"' + reply.replace('"', '\\"') + '"}\n\n'

        # 履歴は completed として保存（abort時は aborted にするなどは後で拡張可）
        _append_message(cm, chat_id, "assistant", reply, status="completed")
        return Response(gen(), mimetype="text/event-stream")

    def message_abort() -> Dict[str, Any]:
        _ABORT.set()
        return {"success": True}

    ir.register("message.handle", message_handle, meta={"component": "services_message_stub_v1"})
    ir.register("message.handle_stream", message_handle_stream, meta={"component": "services_message_stub_v1"})
    ir.register("message.abort", message_abort, meta={"component": "services_message_stub_v1"})
2-3. io_http_api（HTTP入口を1つに統合：API全部ここ）
ecosystem/default/backend/components/io_http_api/manifest.json
Copy{
  "type": "io",
  "id": "io_http_api_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["io.http.binders"], "requires": ["service.chats", "service.relationships"] },
  "metadata": { "description": "HTTP APIを一括でバインド（chats/relationships/settings/ecosystem/kernel/message）。prompt/ai/toolは501で明示。" }
}
ecosystem/default/backend/components/io_http_api/runtime_boot.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional, Set
import json

from rumi_foundation.http.routes import safe_add_url_rule

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify

        # --- helpers ---
        def chats():
            return kernel.interface_registry.get("service.chats", strategy="last")

        def rels():
            return kernel.interface_registry.get("service.relationships", strategy="last")

        # --- core diagnostics ---
        def api_diagnostics():
            return jsonify(kernel.diagnostics.as_dict())
        safe_add_url_rule(app, "/api/diagnostics", "io_http_api.diagnostics", api_diagnostics, {"GET"})
        safe_add_url_rule(app, "/api/kernel/diagnostics", "io_http_api.kernel_diagnostics", api_diagnostics, {"GET"})

        # --- message (new) ---
        def api_message():
            payload = request.get_json(silent=True) or {}
            chat_id = payload.get("chat_id") or request.args.get("chat_id")
            if not chat_id:
                return jsonify({"success": False, "error": "missing chat_id"}), 400
            fn = kernel.interface_registry.get("message.handle", strategy="last")
            if not callable(fn):
                return jsonify({"success": False, "error": "message.handle not provided"}), 500
            out = fn(chat_id, payload)
            return jsonify(out)
        safe_add_url_rule(app, "/api/message", "io_http_api.message", api_message, {"POST"})

        def api_message_stream():
            payload = request.get_json(silent=True) or {}
            chat_id = payload.get("chat_id") or request.args.get("chat_id")
            if not chat_id:
                return jsonify({"success": False, "error": "missing chat_id"}), 400
            fn = kernel.interface_registry.get("message.handle_stream", strategy="last")
            if not callable(fn):
                return jsonify({"success": False, "error": "message.handle_stream not provided"}), 500
            return fn(chat_id, payload)
        safe_add_url_rule(app, "/api/message/stream", "io_http_api.message_stream", api_message_stream, {"POST"})

        # --- legacy message endpoints (keep frontend compatibility) ---
        def legacy_send_message(chat_id: str):
            payload = request.get_json(silent=True) or {}
            payload["streaming"] = False
            fn = kernel.interface_registry.get("message.handle", strategy="last")
            return jsonify(fn(chat_id, payload)) if callable(fn) else jsonify({"success": False, "error": "message.handle missing"}), 500
        safe_add_url_rule(app, "/api/chats/<chat_id>/send_message", "io_http_api.legacy_send_message", legacy_send_message, {"POST"})

        def legacy_send_message_stream(chat_id: str):
            payload = request.get_json(silent=True) or {}
            payload["streaming"] = True
            fn = kernel.interface_registry.get("message.handle_stream", strategy="last")
            return fn(chat_id, payload) if callable(fn) else (jsonify({"success": False, "error": "message.handle_stream missing"}), 500)
        safe_add_url_rule(app, "/api/chats/<chat_id>/send_message_stream", "io_http_api.legacy_send_message_stream", legacy_send_message_stream, {"POST"})

        def legacy_abort():
            fn = kernel.interface_registry.get("message.abort", strategy="last")
            if callable(fn):
                return jsonify(fn())
            return jsonify({"success": False, "error": "message.abort not provided"}), 500
        safe_add_url_rule(app, "/api/stream/abort", "io_http_api.legacy_abort", legacy_abort, {"POST"})

        # --- user settings (prompt/ai/tool無しでも動く) ---
        def user_settings():
            from settings_manager import SettingsManager
            sm = SettingsManager()
            if request.method == "GET":
                return jsonify(sm.get_user_settings())
            data = request.get_json(silent=True)
            if not isinstance(data, dict):
                data = {}
            sm.save_user_settings(data)
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/user/settings", "io_http_api.user_settings", user_settings, {"GET", "POST"})

        # --- chats CRUD ---
        def create_folder():
            data = request.get_json(silent=True) or {}
            name = (data.get("name") or "").strip()
            try:
                folder = chats().create_folder(name)
                return jsonify({"success": True, "folder_name": folder}), 201
            except Exception as e:
                return jsonify({"success": False, "error": str(e)}), 400
        safe_add_url_rule(app, "/api/folders", "io_http_api.create_folder", create_folder, {"POST"})

        def chats_list():
            return jsonify(chats().get_all_chats())
        safe_add_url_rule(app, "/api/chats", "io_http_api.chats_list", chats_list, {"GET"})

        def chats_create():
            data = request.get_json(silent=True) or {}
            folder = data.get("folder")
            meta = chats().create_chat(folder)
            return jsonify(meta), 201
        safe_add_url_rule(app, "/api/chats", "io_http_api.chats_create", chats_create, {"POST"})

        def chat_single(chat_id: str):
            cm = chats()
            if request.method == "GET":
                try:
                    return jsonify(cm.load_chat_history(chat_id))
                except FileNotFoundError:
                    return jsonify({"metadata": {"title": "新しいチャット", "is_pinned": False, "folder": None}, "messages": []})
            if request.method == "DELETE":
                try:
                    rels().delete_all_links_for(chat_id)
                    cm.delete_chat(chat_id)
                    return jsonify({"success": True})
                except FileNotFoundError:
                    return jsonify({"error": "Chat not found"}), 404
            # PATCH
            cm.update_chat_metadata(chat_id, request.get_json(silent=True) or {})
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/chats/<chat_id>", "io_http_api.chat_single", chat_single, {"GET", "DELETE", "PATCH"})

        def chat_copy(chat_id: str):
            new_id = chats().copy_chat(chat_id)
            return jsonify({"success": True, "new_chat_id": new_id}), 201
        safe_add_url_rule(app, "/api/chats/<chat_id>/copy", "io_http_api.chat_copy", chat_copy, {"POST"})

        # --- ui_history (optional but keeps UI stable) ---
        def ui_history(chat_id: str):
            return jsonify(chats().load_ui_history(chat_id))
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history", "io_http_api.ui_history", ui_history, {"GET"})

        def ui_history_logs(chat_id: str):
            exec_id = request.args.get("execution_id")
            cm = chats()
            ui = cm.load_ui_history(chat_id)
            logs = cm.get_tool_logs_for_execution(chat_id, exec_id) if exec_id else ui.get("tool_logs", [])
            return jsonify({"logs": logs})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/logs", "io_http_api.ui_history_logs", ui_history_logs, {"GET"})

        def ui_history_append(chat_id: str):
            log = request.get_json(silent=True) or {}
            mid = chats().append_tool_log(chat_id, log)
            return jsonify({"success": True, "message_id": mid})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/append_log", "io_http_api.ui_history_append", ui_history_append, {"POST"})

        def ui_state(chat_id: str):
            cm = chats()
            if request.method == "GET":
                ui = cm.load_ui_history(chat_id)
                return jsonify({"ui_state": ui.get("ui_state", {})})
            updates = request.get_json(silent=True) or {}
            for k, v in updates.items():
                cm.update_ui_state(chat_id, k, v)
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/state", "io_http_api.ui_state", ui_state, {"GET", "POST"})

        def ui_history_clear(chat_id: str):
            chats().clear_ui_history(chat_id)
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/clear", "io_http_api.ui_history_clear", ui_history_clear, {"DELETE"})

        # --- relationships ---
        def relationships():
            rm = rels()
            if request.method == "GET":
                entity_id = request.args.get("entity_id")
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")
                links = rm.get_related(entity_id, link_type, direction) if entity_id else rm.get_all_links()
                return jsonify({"links": links})
            data = request.get_json(silent=True) or {}
            for f in ("source", "target", "type"):
                if f not in data:
                    return jsonify({"error": f"{f} is required"}), 400
            link = rm.link(data["source"], data["target"], data["type"], data.get("metadata", {}))
            return jsonify({"success": True, "link": link}), 201
        safe_add_url_rule(app, "/api/relationships", "io_http_api.relationships", relationships, {"GET", "POST"})

        def relationships_entity(entity_id: str):
            rm = rels()
            if request.method == "GET":
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")
                links = rm.get_related(entity_id, link_type, direction)
                ids = rm.get_related_ids(entity_id, link_type, direction)
                return jsonify({"entity_id": entity_id, "links": links, "related_ids": ids})
            data = request.get_json(silent=True) or {}
            target = data.get("target")
            link_type = data.get("type")
            if target and link_type:
                ok = rm.unlink(entity_id, target, link_type)
                return jsonify({"success": ok}), (200 if ok else 404)
            count = rm.delete_all_links_for(entity_id)
            return jsonify({"success": True, "deleted_count": count})
        safe_add_url_rule(app, "/api/relationships/<entity_id>", "io_http_api.relationships_entity", relationships_entity, {"GET", "DELETE"})

        # --- ecosystem admin ---
        def ecosystem_status():
            from backend_core.ecosystem.compat import is_ecosystem_initialized
            from backend_core.ecosystem import get_registry, get_active_ecosystem_manager
            if not is_ecosystem_initialized():
                return jsonify({"initialized": False, "message": "エコシステムは初期化されていません"})
            reg = get_registry()
            active = get_active_ecosystem_manager()
            return jsonify({
                "initialized": True,
                "active_pack_identity": active.active_pack_identity,
                "packs": list(reg.packs.keys()),
                "total_components": len(reg.get_all_components()),
                "overrides": active.get_all_overrides(),
            })
        safe_add_url_rule(app, "/api/ecosystem/status", "io_http_api.ecosystem_status", ecosystem_status, {"GET"})

        # --- removed subsystems stubs (prompt/ai/tool) ---
        def not_implemented(name: str):
            return jsonify({"success": False, "error": f"{name} subsystem removed; implement it as ecosystem service/IO."}), 501
        safe_add_url_rule(app, "/api/prompts", "io_http_api.prompts_stub", lambda: not_implemented("prompt"), {"GET"})
        safe_add_url_rule(app, "/api/ai/models", "io_http_api.ai_stub", lambda: not_implemented("ai_client"), {"GET"})
        safe_add_url_rule(app, "/api/tools/debug", "io_http_api.tools_stub", lambda: not_implemented("tool"), {"GET"})

    ir.register("io.http.binders", bind_http, meta={"component": "io_http_api_v1"})
3) 旧 io_http_* コンポーネントの扱い（重要）
あなたが「prompt/ai_client/toolは消す」と言っているので、今まで増えた io_http_ や bridge_message 等は一度全削除してOKです。最終形は上の foundation + services_ + io_http_api だけで足ります。

推奨：ecosystem/default/backend/components/ を一旦空にして、上で示したフォルダだけにする。

A) 既存ファイルの修正（修正部分のみ）
A-1) core_runtime/component_lifecycle.py
1) runtime_boot フェーズを追加
Copy# --- 修正箇所: core_runtime/component_lifecycle.py ---

def run_phase(self, phase_name: str) -> Dict[str, Any]:
    phase = (phase_name or "").strip()
    if phase not in ("dependency", "setup", "runtime_boot"):
        ...
2) phase 実行前に「アクティブコンポーネントの runtime_dir を sys.path に追加」（贔屓なし・汎用）
これにより、component が 他 component の Python package を importできます（foundation 共有が成立）。

Copy# --- 修正箇所: core_runtime/component_lifecycle.py（ComponentLifecycleExecutor クラス内に追加） ---

def _ensure_components_on_syspath(self, components: list) -> None:
    import sys
    try:
        for comp in components:
            p = str(Path(getattr(comp, "path", ".")).resolve())
            if p and p not in sys.path:
                sys.path.insert(0, p)
    except Exception:
        # fail-soft
        return
そして run_phase() の components = self.iter_active_components(...) 直後に追加：

Copy# --- 修正箇所: core_runtime/component_lifecycle.py（run_phase 内） ---

components = self.iter_active_components(phase=phase)
self._ensure_components_on_syspath(components)
3) _run_phase_for_component の filename を runtime_boot まで拡張
Copy# --- 修正箇所: core_runtime/component_lifecycle.py ---

if phase == "dependency":
    filename = "dependency_manager.py"
elif phase == "setup":
    filename = "setup.py"
else:  # runtime_boot
    filename = "runtime_boot.py"
file_path = runtime_dir / filename
A-2) flow/project.flow.yaml（既存）
startup に runtime_boot を追加（setup の直後推奨）：

Copy# --- 修正箇所: flow/project.flow.yaml の pipelines.startup に追加 ---
- id: "startup.runtime_boot"
  run:
    handler: "component_phase:runtime_boot"
    args: {}
  optional: true
  on_error:
    action: "continue"
※あなたの flow は JSON 内容の .yaml でもOKです。同様に JSON で追加しても構いません。

A-3) app.py（既存）—「/api ルート全撤去」＆最小ランナー化
既存 app.py は巨大なので、**この方針が “修正部分=全体”**になります。あなたのルール上「既存は修正部分のみ」なので、これは **“app.py を下記に置き換える”**として提示します（全行が変更対象）。

置き換え理由：APIを残すとルート重複・順不同移行事故の温床になるため。README思想（公式が贔屓しない）とも一致。

修正（置換）: app.py 全体を以下に置き換え
Copyimport os
import threading
import traceback
from flask import Flask, render_template
from dotenv import load_dotenv

load_dotenv('.env.local')
app = Flask(__name__)

_kernel = None
_kernel_started = False
_kernel_start_lock = threading.Lock()

# --- Kernel bootstrap (lazy, pre-routing) ---

def ensure_kernel_started():
    global _kernel, _kernel_started
    if _kernel_started:
        return
    with _kernel_start_lock:
        if _kernel_started:
            return
        try:
            from core_runtime import Kernel
            _kernel = Kernel()
            _kernel.run_startup()

            # compat 追随（fail-soft）。将来はKernel handler側へ寄せて app.py から消せる。
            try:
                from backend_core.ecosystem.compat import mark_ecosystem_initialized
                mark_ecosystem_initialized()
            except Exception:
                pass

        except Exception as e:
            # fail-soft: 起動失敗でもプロセスは立てる（diagnosticsは /api/diagnostics 側で見える想定）
            print(f"[Kernel] startup failed (fail-soft): {e}")
            traceback.print_exc()
        finally:
            _kernel_started = True


def apply_http_binders():
    """
    ecosystem が登録する io.http.binders を適用する（idempotent前提）。
    """
    if _kernel is None:
        return
    try:
        binders = _kernel.interface_registry.get("io.http.binders", strategy="all") or []
        if not isinstance(binders, list):
            binders = [binders]
        for b in binders:
            if callable(b):
                try:
                    b(app, _kernel, {"app": app})
                except Exception:
                    traceback.print_exc()
    except Exception:
        traceback.print_exc()


class _KernelWSGIMiddleware:
    """
    WSGI入口で Kernel startup + HTTP bind を実行し、初回リクエストの404を防ぐ。
    """
    def __init__(self, wsgi_app):
        self._wsgi_app = wsgi_app
        self._init_lock = threading.Lock()
        self._initialized = False

    def __call__(self, environ, start_response):
        if not self._initialized:
            with self._init_lock:
                if not self._initialized:
                    ensure_kernel_started()
                    apply_http_binders()
                    self._initialized = True

        # 段階的に binder が増えても良いよう、毎回軽く試す（idempotent前提）
        apply_http_binders()
        return self._wsgi_app(environ, start_response)


app.wsgi_app = _KernelWSGIMiddleware(app.wsgi_app)

# --- UI routes only (official keeps UI shell only) ---

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/chats/<chat_id>')
def show_chat(chat_id):
    return render_template('index.html')


if __name__ == '__main__':
    app.run(debug=True, port=5000)
B) 新規ファイル（全文）
以下を 新規追加してください。これが「prompt/ai/tool無しで動くバックエンド基盤」一式です。

B-1) foundation（safe_add_url_rule）
ecosystem/default/backend/components/foundation/manifest.json
Copy{
  "type": "foundation",
  "id": "foundation_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["foundation.http.routes"], "requires": [] },
  "metadata": { "description": "共通基盤（safe_add_url_rule など）" }
}
ecosystem/default/backend/components/foundation/runtime_boot.py
Copyfrom __future__ import annotations
from typing import Any, Dict

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if ir:
        ir.register("foundation.http.routes", {"version": "1.0"}, meta={"component": "foundation_v1"})
ecosystem/default/backend/components/foundation/rumi_foundation/__init__.py
Copy__all__ = []
ecosystem/default/backend/components/foundation/rumi_foundation/http/__init__.py
Copy__all__ = ["routes"]
ecosystem/default/backend/components/foundation/rumi_foundation/http/routes.py
Copyfrom __future__ import annotations
from typing import Callable, Optional, Set, Any

def route_exists(app, rule: str, methods: Optional[Set[str]] = None) -> bool:
    want = set(m.upper() for m in (methods or set()))
    for r in app.url_map.iter_rules():
        if str(r.rule) != rule:
            continue
        if want:
            existing = set(m.upper() for m in (r.methods or set()))
            if not want.issubset(existing):
                continue
        return True
    return False

def safe_add_url_rule(app, rule: str, endpoint: str, view_func: Callable[..., Any], methods: Set[str]) -> bool:
    if route_exists(app, rule, methods):
        return False
    app.add_url_rule(rule, endpoint=endpoint, view_func=view_func, methods=sorted(list(methods)))
    return True
B-2) services: chats / relationships / message_stub
ecosystem/default/backend/components/services_chats/manifest.json
Copy{
  "type": "service",
  "id": "services_chats_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["service.chats"], "requires": [] },
  "metadata": { "description": "Chatサービス（ChatManager提供）" }
}
ecosystem/default/backend/components/services_chats/runtime_boot.py
Copyfrom __future__ import annotations
from typing import Any, Dict

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return
    from chat_manager import ChatManager
    ir.register("service.chats", ChatManager(), meta={"component": "services_chats_v1"})
ecosystem/default/backend/components/services_relationships/manifest.json
Copy{
  "type": "service",
  "id": "services_relationships_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["service.relationships"], "requires": [] },
  "metadata": { "description": "Relationshipサービス（RelationshipManager提供）" }
}
ecosystem/default/backend/components/services_relationships/runtime_boot.py
Copyfrom __future__ import annotations
from typing import Any, Dict

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return
    from relationship_manager import RelationshipManager
    ir.register("service.relationships", RelationshipManager(), meta={"component": "services_relationships_v1"})
ecosystem/default/backend/components/services_message_stub/manifest.json
Copy{
  "type": "service",
  "id": "services_message_stub_v1",
  "version": "1.0.0",
  "connectivity": {
    "provides": ["message.handle", "message.handle_stream", "message.abort"],
    "requires": ["service.chats"]
  },
  "metadata": { "description": "AI未実装時のメッセージ処理（履歴保存＋スタブ応答）" }
}
ecosystem/default/backend/components/services_message_stub/runtime_boot.py
Copyfrom __future__ import annotations

from typing import Any, Dict
import threading
import time

_ABORT = threading.Event()

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return

    def _chats():
        return ir.get("service.chats", strategy="last")

    def _append(chat_id: str, role: str, content: str, status: str = "completed") -> None:
        cm = _chats()
        from chat_manager import create_standard_message, add_message_to_history
        history = cm.load_chat_history(chat_id)
        msg = create_standard_message(
            role=role,
            content=content,
            parent_id=history.get("current_node"),
            status=status,
        )
        history = add_message_to_history(history, msg)
        cm.save_chat_history(chat_id, history)

    STUB = "AI subsystem is not installed yet. (prompt/ai_client/tool were removed; implement new services and rebind message.handle.)"

    def message_handle(chat_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        msg = (payload or {}).get("message") or {}
        text = msg.get("text", "") if isinstance(msg, dict) else ""
        if text.strip():
            _append(chat_id, "user", text)
        _append(chat_id, "assistant", STUB)
        return {"success": True, "response": STUB, "metadata": {"chat_id": chat_id}}

    def message_handle_stream(chat_id: str, payload: Dict[str, Any]):
        from flask import Response
        _ABORT.clear()

        msg = (payload or {}).get("message") or {}
        text = msg.get("text", "") if isinstance(msg, dict) else ""
        if text.strip():
            _append(chat_id, "user", text)

        def gen():
            yield 'data: {"type":"chunk","text":"'
            for ch in STUB:
                if _ABORT.is_set():
                    yield '"}\n\n'
                    return
                yield ch.replace('"', '\\"')
                time.sleep(0.003)
            yield '"}\n\n'
            yield 'data: {"type":"complete","full_text":"' + STUB.replace('"', '\\"') + '"}\n\n'

        _append(chat_id, "assistant", STUB)
        return Response(gen(), mimetype="text/event-stream")

    def message_abort() -> Dict[str, Any]:
        _ABORT.set()
        return {"success": True}

    ir.register("message.handle", message_handle, meta={"component": "services_message_stub_v1"})
    ir.register("message.handle_stream", message_handle_stream, meta={"component": "services_message_stub_v1"})
    ir.register("message.abort", message_abort, meta={"component": "services_message_stub_v1"})
B-3) IO: HTTP APIを一括で提供（io_http_api）
ecosystem/default/backend/components/io_http_api/manifest.json
Copy{
  "type": "io",
  "id": "io_http_api_v1",
  "version": "1.0.0",
  "connectivity": { "provides": ["io.http.binders"], "requires": ["service.chats", "service.relationships"] },
  "metadata": { "description": "HTTP API一括バインド（prompt/ai/tool無しで動作、該当APIは501）" }
}
ecosystem/default/backend/components/io_http_api/runtime_boot.py
Copyfrom __future__ import annotations

from typing import Any, Dict, Optional
from rumi_foundation.http.routes import safe_add_url_rule

def run(context: Dict[str, Any]) -> None:
    ir = context.get("interface_registry")
    if not ir:
        return

    def bind_http(app, kernel, ctx: Optional[Dict[str, Any]] = None) -> None:
        from flask import request, jsonify

        def chats():
            return kernel.interface_registry.get("service.chats", strategy="last")

        def rels():
            return kernel.interface_registry.get("service.relationships", strategy="last")

        # diagnostics
        safe_add_url_rule(app, "/api/diagnostics", "io_http_api.diagnostics", lambda: jsonify(kernel.diagnostics.as_dict()), {"GET"})
        safe_add_url_rule(app, "/api/kernel/diagnostics", "io_http_api.kernel_diagnostics", lambda: jsonify(kernel.diagnostics.as_dict()), {"GET"})

        # message (new)
        def api_message():
            payload = request.get_json(silent=True) or {}
            chat_id = payload.get("chat_id") or request.args.get("chat_id")
            if not chat_id:
                return jsonify({"success": False, "error": "missing chat_id"}), 400
            fn = kernel.interface_registry.get("message.handle", strategy="last")
            if not callable(fn):
                return jsonify({"success": False, "error": "message.handle not provided"}), 500
            return jsonify(fn(chat_id, payload))
        safe_add_url_rule(app, "/api/message", "io_http_api.message", api_message, {"POST"})

        def api_message_stream():
            payload = request.get_json(silent=True) or {}
            chat_id = payload.get("chat_id") or request.args.get("chat_id")
            if not chat_id:
                return jsonify({"success": False, "error": "missing chat_id"}), 400
            fn = kernel.interface_registry.get("message.handle_stream", strategy="last")
            if not callable(fn):
                return jsonify({"success": False, "error": "message.handle_stream not provided"}), 500
            return fn(chat_id, payload)
        safe_add_url_rule(app, "/api/message/stream", "io_http_api.message_stream", api_message_stream, {"POST"})

        # legacy message endpoints
        def legacy_send_message(chat_id: str):
            payload = request.get_json(silent=True) or {}
            payload["streaming"] = False
            fn = kernel.interface_registry.get("message.handle", strategy="last")
            if not callable(fn):
                return jsonify({"success": False, "error": "message.handle missing"}), 500
            return jsonify(fn(chat_id, payload))
        safe_add_url_rule(app, "/api/chats/<chat_id>/send_message", "io_http_api.legacy_send_message", legacy_send_message, {"POST"})

        def legacy_send_message_stream(chat_id: str):
            payload = request.get_json(silent=True) or {}
            payload["streaming"] = True
            fn = kernel.interface_registry.get("message.handle_stream", strategy="last")
            if not callable(fn):
                return jsonify({"success": False, "error": "message.handle_stream missing"}), 500
            return fn(chat_id, payload)
        safe_add_url_rule(app, "/api/chats/<chat_id>/send_message_stream", "io_http_api.legacy_send_message_stream", legacy_send_message_stream, {"POST"})

        def legacy_abort():
            fn = kernel.interface_registry.get("message.abort", strategy="last")
            return jsonify(fn()) if callable(fn) else (jsonify({"success": False, "error": "message.abort missing"}), 500)
        safe_add_url_rule(app, "/api/stream/abort", "io_http_api.legacy_abort", legacy_abort, {"POST"})

        # user settings
        def user_settings():
            from settings_manager import SettingsManager
            sm = SettingsManager()
            if request.method == "GET":
                return jsonify(sm.get_user_settings())
            data = request.get_json(silent=True)
            if not isinstance(data, dict):
                data = {}
            sm.save_user_settings(data)
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/user/settings", "io_http_api.user_settings", user_settings, {"GET", "POST"})

        # folders + chats CRUD
        def create_folder():
            data = request.get_json(silent=True) or {}
            name = (data.get("name") or "").strip()
            try:
                folder = chats().create_folder(name)
                return jsonify({"success": True, "folder_name": folder}), 201
            except Exception as e:
                return jsonify({"success": False, "error": str(e)}), 400
        safe_add_url_rule(app, "/api/folders", "io_http_api.create_folder", create_folder, {"POST"})

        safe_add_url_rule(app, "/api/chats", "io_http_api.chats_list", lambda: jsonify(chats().get_all_chats()), {"GET"})

        def chats_create():
            data = request.get_json(silent=True) or {}
            meta = chats().create_chat(data.get("folder", None))
            return jsonify(meta), 201
        safe_add_url_rule(app, "/api/chats", "io_http_api.chats_create", chats_create, {"POST"})

        def chat_single(chat_id: str):
            cm = chats()
            if request.method == "GET":
                try:
                    return jsonify(cm.load_chat_history(chat_id))
                except FileNotFoundError:
                    return jsonify({"metadata": {"title": "新しいチャット", "is_pinned": False, "folder": None}, "messages": []})
            if request.method == "DELETE":
                try:
                    rels().delete_all_links_for(chat_id)
                    cm.delete_chat(chat_id)
                    return jsonify({"success": True})
                except FileNotFoundError:
                    return jsonify({"error": "Chat not found"}), 404
            cm.update_chat_metadata(chat_id, request.get_json(silent=True) or {})
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/chats/<chat_id>", "io_http_api.chat_single", chat_single, {"GET", "DELETE", "PATCH"})

        def chat_copy(chat_id: str):
            new_id = chats().copy_chat(chat_id)
            return jsonify({"success": True, "new_chat_id": new_id}), 201
        safe_add_url_rule(app, "/api/chats/<chat_id>/copy", "io_http_api.chat_copy", chat_copy, {"POST"})

        # ui_history
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history", "io_http_api.ui_history", lambda chat_id: jsonify(chats().load_ui_history(chat_id)), {"GET"})

        def ui_history_logs(chat_id: str):
            exec_id = request.args.get("execution_id")
            cm = chats()
            ui = cm.load_ui_history(chat_id)
            logs = cm.get_tool_logs_for_execution(chat_id, exec_id) if exec_id else ui.get("tool_logs", [])
            return jsonify({"logs": logs})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/logs", "io_http_api.ui_history_logs", ui_history_logs, {"GET"})

        def ui_history_append(chat_id: str):
            log = request.get_json(silent=True) or {}
            mid = chats().append_tool_log(chat_id, log)
            return jsonify({"success": True, "message_id": mid})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/append_log", "io_http_api.ui_history_append", ui_history_append, {"POST"})

        def ui_state(chat_id: str):
            cm = chats()
            if request.method == "GET":
                ui = cm.load_ui_history(chat_id)
                return jsonify({"ui_state": ui.get("ui_state", {})})
            updates = request.get_json(silent=True) or {}
            for k, v in updates.items():
                cm.update_ui_state(chat_id, k, v)
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/state", "io_http_api.ui_state", ui_state, {"GET", "POST"})

        def ui_history_clear(chat_id: str):
            chats().clear_ui_history(chat_id)
            return jsonify({"success": True})
        safe_add_url_rule(app, "/api/chats/<chat_id>/ui_history/clear", "io_http_api.ui_history_clear", ui_history_clear, {"DELETE"})

        # relationships
        def relationships():
            rm = rels()
            if request.method == "GET":
                entity_id = request.args.get("entity_id")
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")
                links = rm.get_related(entity_id, link_type, direction) if entity_id else rm.get_all_links()
                return jsonify({"links": links})
            data = request.get_json(silent=True) or {}
            for f in ("source", "target", "type"):
                if f not in data:
                    return jsonify({"error": f"{f} is required"}), 400
            link = rm.link(data["source"], data["target"], data["type"], data.get("metadata", {}))
            return jsonify({"success": True, "link": link}), 201
        safe_add_url_rule(app, "/api/relationships", "io_http_api.relationships", relationships, {"GET", "POST"})

        def relationships_entity(entity_id: str):
            rm = rels()
            if request.method == "GET":
                link_type = request.args.get("type")
                direction = request.args.get("direction", "both")
                links = rm.get_related(entity_id, link_type, direction)
                ids = rm.get_related_ids(entity_id, link_type, direction)
                return jsonify({"entity_id": entity_id, "links": links, "related_ids": ids})
            data = request.get_json(silent=True) or {}
            target = data.get("target")
            link_type = data.get("type")
            if target and link_type:
                ok = rm.unlink(entity_id, target, link_type)
                return jsonify({"success": ok}), (200 if ok else 404)
            count = rm.delete_all_links_for(entity_id)
            return jsonify({"success": True, "deleted_count": count})
        safe_add_url_rule(app, "/api/relationships/<entity_id>", "io_http_api.relationships_entity", relationships_entity, {"GET", "DELETE"})

        # ecosystem admin (minimal)
        def ecosystem_status():
            from backend_core.ecosystem.compat import is_ecosystem_initialized
            from backend_core.ecosystem import get_registry, get_active_ecosystem_manager
            if not is_ecosystem_initialized():
                return jsonify({"initialized": False, "message": "エコシステムは初期化されていません"})
            reg = get_registry()
            active = get_active_ecosystem_manager()
            return jsonify({
                "initialized": True,
                "active_pack_identity": active.active_pack_identity,
                "packs": list(reg.packs.keys()),
                "total_components": len(reg.get_all_components()),
                "overrides": active.get_all_overrides(),
            })
        safe_add_url_rule(app, "/api/ecosystem/status", "io_http_api.ecosystem_status", ecosystem_status, {"GET"})

        # removed subsystems stubs (explicit)
        def not_impl(name: str):
            return jsonify({"success": False, "error": f"{name} subsystem removed; implement as ecosystem components."}), 501

        safe_add_url_rule(app, "/api/prompts", "io_http_api.prompts_stub", lambda: not_impl("prompt"), {"GET"})
        safe_add_url_rule(app, "/api/ai/models", "io_http_api.ai_stub", lambda: not_impl("ai_client"), {"GET"})
        safe_add_url_rule(app, "/api/tools/debug", "io_http_api.tools_stub", lambda: not_impl("tool"), {"GET"})

    ir.register("io.http.binders", bind_http, meta={"component": "io_http_api_v1"})