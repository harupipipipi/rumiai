================================================================================
                    AI Invoke History Integration Memo
                        将来のhistory直投げ設計メモ
================================================================================

作成日: 2025-01-XX
ステータス: 設計メモ（未実装）

================================================================================
1. 背景
================================================================================

現在のdirect invoke APIは1ターンの独立した呼び出しを想定している。
将来的には、app.pyがチャットのhistory.json（標準形式）をdirect invokeに
直接投げて、既存の会話コンテキストを維持したまま応答を得たい。

これにより：
- ai_client_v2 のような別実装をフロントから切り替えても疎通しやすい
- ReActループなど複雑な処理をai_client側に移譲できる
- チャットUIとバッチ処理で同じ履歴形式を使える

================================================================================
2. 想定API拡張
================================================================================

POST /api/ai/invoke
{
  "model_id": "gemini-2.5-flash",
  "message": "現在のメッセージ",
  
  // 新規追加（将来）
  "history": {
    "conversation_id": "...",
    "schema_version": "2.0",
    "messages": [...],
    "mapping": {...},
    "current_node": "..."
  },
  
  // または履歴参照
  "chat_id": "既存チャットのUUID",
  
  // 履歴に応答を自動追加するか
  "append_to_history": false,
  
  // その他既存パラメータ
  "system_prompt": "...",
  "tools_config": {...},
  "params": {...},
  "api_tier": "standard",
  "external_tools": {...},
  "tooluse_output": "json"
}

================================================================================
3. 履歴形式の互換性
================================================================================

標準形式（schema_version: "2.0"）との互換性を維持：

【標準形式の構造】
{
  "conversation_id": "uuid-string",
  "title": "会話タイトル",
  "schema_version": "2.0",
  "created_at": "2025-01-01T00:00:00.000Z",
  "updated_at": "2025-01-01T00:00:00.000Z",
  "model": "gemini-2.5-flash",
  "platform": "gemini",
  
  "messages": [
    {
      "message_id": "msg-xxxxxxxxxxxx",
      "role": "user" | "assistant" | "tool" | "system",
      "content": "テキスト内容",
      "parent_id": "親メッセージID" | null,
      "children": ["子メッセージID"],
      "timestamp": "2025-01-01T00:00:00.000Z",
      "status": "completed" | "aborted",
      
      // userメッセージのみ
      "attachments": [
        {
          "type": "image" | "video" | "audio" | "file",
          "mime_type": "image/png",
          "url": "/path/to/file",
          "name": "filename.png"
        }
      ],
      
      // assistantメッセージのみ（ツール呼び出し時）
      "tool_calls": [
        {
          "tool_call_id": "call-xxxx",
          "function_name": "web_search",
          "arguments": {"query": "検索クエリ"}
        }
      ],
      
      // toolメッセージのみ
      "tool_call_id": "call-xxxx"
    }
  ],
  
  "mapping": {
    "msg-xxxx": {
      "id": "msg-xxxx",
      "parent": "msg-yyyy" | null,
      "children": ["msg-zzzz"]
    }
  },
  
  "current_node": "msg-zzzzzzzzzzzz",
  "active_tools": null | ["tool1", "tool2"],
  "active_supporters": ["supporter1"]
}

【invoke時の履歴変換フロー】
1. current_nodeからparent_idを辿ってスレッドを抽出
2. プロバイダー固有の形式に変換（既存のconvert_standard_to_*を利用）
3. 現在のmessageを末尾に追加
4. API呼び出し

================================================================================
4. 実装時の考慮事項
================================================================================

(1) 履歴の渡し方
    - 完全な履歴オブジェクトをリクエストに含める
      - メリット: ステートレス、サーバー状態非依存
      - デメリット: リクエストサイズ増大
    - または chat_id を指定して内部でロード
      - メリット: リクエスト軽量
      - デメリット: サーバー状態依存
    - 両方サポートし、historyがあればそれを優先、なければchat_idでロード

(2) 応答の履歴への反映
    - invoke結果を履歴に自動追加するか
    - 呼び出し元（app.py）に任せるか
    - オプション append_to_history: boolean で制御可能にする
    - デフォルトは false（現在の1ターン独立動作を維持）

(3) ツール実行の履歴記録
    - tool_callsとtool応答も履歴に記録
    - ReActループの各ステップを追跡可能に
    - 記録形式は標準形式に準拠

(4) 分岐対応
    - 同じ位置から複数回invokeした場合の分岐
    - childrenに複数のノードが追加される
    - current_nodeは最後に追加されたノードを指す

(5) エラー時の履歴
    - API呼び出し失敗時は履歴に追加しない
    - 部分的な応答（中断など）はstatus: "aborted"で記録

================================================================================
5. 移行パス
================================================================================

【Phase 1（現在実装済み）】
- direct invokeは1ターン独立実行
- 履歴なし（空の標準履歴で実行）
- chat_managerとは独立

【Phase 2（将来）】
- historyパラメータを追加
- 既存の1ターン実行と後方互換
- history指定時はそれを使用してコンテキスト維持

【Phase 3（将来）】
- chat_idによる履歴参照
- append_to_historyオプション
- 応答の自動記録

【Phase 4（将来）】
- ReActループの内部実行
- 複数ターンの自動処理
- max_iterationsパラメータ

================================================================================
6. コード変更箇所（Phase 2実装時）
================================================================================

【ai_manager.py - direct_invokeメソッド】
def direct_invoke(
    self,
    model_id: str,
    message: str,
    history: Dict = None,        # 追加
    chat_id: str = None,         # 追加
    append_to_history: bool = False,  # 追加
    # ... 既存パラメータ
) -> Dict[str, Any]:
    
    # 履歴の取得
    if history:
        # 直接渡された履歴を使用
        working_history = history
    elif chat_id:
        # chat_idから履歴をロード
        working_history = chat_manager.load_chat_history(chat_id)
    else:
        # 空の履歴を作成（現在の動作）
        working_history = create_standard_history()
    
    # 会話スレッドを取得
    thread = get_conversation_thread(working_history)
    
    # 以降は既存のロジック...

【app.py - /api/ai/invoke エンドポイント】
- history パラメータの受け入れ
- chat_id パラメータの受け入れ
- append_to_history パラメータの受け入れ
- バリデーション追加

================================================================================
7. セキュリティ考慮事項
================================================================================

(1) 履歴の検証
    - schema_versionの確認
    - 必須フィールドの存在確認
    - messagesの構造検証
    - 悪意のあるデータの排除

(2) chat_idアクセス制御
    - 将来的にはユーザー認証と組み合わせ
    - 他ユーザーの履歴にアクセスできないように

(3) 履歴サイズ制限
    - 巨大な履歴によるDoS防止
    - messages数の上限
    - 総トークン数の制限

================================================================================
8. 関連ファイル
================================================================================

- ai_manager.py: direct_invoke() メソッド
- chat_manager.py: 標準形式ヘルパー関数
  - create_standard_history()
  - create_standard_message()
  - add_message_to_history()
  - get_conversation_thread()
- message_handler.py: 現在のReActループ実装（参考）
- app.py: /api/ai/invoke エンドポイント

================================================================================
9. テスト計画（Phase 2実装時）
================================================================================

(1) 単体テスト
    - history引数の正しい処理
    - chat_id引数の正しい処理
    - 両方指定時の優先順位
    - 不正な履歴データの拒否

(2) 統合テスト
    - 既存チャットの履歴を使用したinvoke
    - 応答の履歴追加（append_to_history=true）
    - ツール実行を含むフロー

(3) 後方互換性テスト
    - history/chat_id未指定時の既存動作確認
    - 既存のAPIクライアントとの互換性

================================================================================
10. 参考: 他サービスのアプローチ
================================================================================

【OpenAI Chat Completions API】
- messagesを配列で直接渡す
- 履歴管理はクライアント側の責任
- ステートレス設計

【Anthropic Messages API】
- messagesを配列で直接渡す
- systemは別パラメータ
- ステートレス設計

【Google Gemini API】
- historyとしてContentsを渡す
- 内部でセッション管理も可能
- 両方のモードをサポート

【本プロジェクトのアプローチ】
- 標準形式の履歴（ツリー構造対応）
- chat_idによるサーバー側履歴参照
- historyによるクライアント側履歴指定
- 両方をサポートし柔軟性を確保

================================================================================