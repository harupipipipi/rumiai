================================================================================
                         TOOL IMPLEMENTATION RULES
                              tool_rule.txt
================================================================================

このファイルは、toolフォルダ内にツールを実装する際のルールを定義します。

--------------------------------------------------------------------------------
1. ディレクトリ構造
--------------------------------------------------------------------------------

tool/
├── tool_loader.py                    # ツール読み込みエンジン（変更禁止）
├── tool_dependency_manager.py        # 依存関係管理（変更禁止）
├── tool_rule.txt                     # このファイル
├── userdata/                         # ユーザーデータ格納場所
│   └── tool_settings.json            # ツール設定ファイル
│
└── [tool_name]/                      # 個別ツールフォルダ
    ├── .venv/                        # 自動生成される仮想環境
    ├── requirements.txt              # 依存ライブラリ（任意）
    ├── [tool_name]_tool.py           # エントリーポイント（必須）
    └── その他のファイル               # 補助モジュール、設定ファイル等

--------------------------------------------------------------------------------
2. ファイル命名規則
--------------------------------------------------------------------------------

- エントリーポイント: `[tool_name]_tool.py`
  例: web_search_tool.py, calculator_tool.py, file_manager_tool.py

- ツールフォルダ名とファイル名のプレフィックスは一致させること
  例: tool/web_search/web_search_tool.py

--------------------------------------------------------------------------------
3. 必須エクスポート
--------------------------------------------------------------------------------

各ツールファイルは以下の変数・関数を必ずエクスポートすること:

【必須変数】
- TOOL_NAME: str          # ツールの表示名（日本語可）
- TOOL_DESCRIPTION: str   # ツールの説明文
- TOOL_ICON: str          # アイコン（絵文字またはURL）

【必須関数】

def get_function_declaration() -> dict:
    """
    Function Calling用の宣言を返す。
    
    Returns:
        dict: 以下の形式の辞書
        {
            "name": str,           # 関数名（英数字とアンダースコアのみ）
            "description": str,    # 関数の説明
            "parameters": {
                "type": "object",
                "properties": {...},
                "required": [...]
            }
        }
    """
    pass

def execute(args: dict, context: dict) -> dict:
    """
    ツールを実行する。
    
    Args:
        args: AIから渡される引数（get_function_declarationのparametersに対応）
        context: 実行コンテキスト（後述）
    
    Returns:
        dict: 実行結果
        {
            "success": bool,       # 成功/失敗
            "result": Any,         # 結果データ（任意形式）
            "error": str,          # エラーメッセージ（失敗時）
            "files": list,         # 生成ファイル情報（任意）
        }
    """
    pass

--------------------------------------------------------------------------------
4. Context オブジェクト仕様
--------------------------------------------------------------------------------

execute関数に渡されるcontextには以下のキーが含まれる:

【基本情報】
- tool_dir: str              # ツールディレクトリの絶対パス
- settings: dict             # ツール固有の設定値
- execution_id: str          # 実行ごとのユニークID

【環境情報】
- has_venv: bool             # 専用仮想環境があるか
- venv_python: str|None      # 仮想環境のPythonパス

【通信用】
- message_callback: callable # 進捗メッセージ送信用コールバック
- abort_event: Event|None    # 中断シグナル

【チャット情報】（将来拡張で追加予定）
- chat_id: str               # 現在のチャットID
- chat_manager: object       # チャット操作オブジェクト

【権限オブジェクト】（将来拡張で追加予定）
- permissions: dict          # 権限情報
- runtime: object            # ランタイム操作オブジェクト

※ contextのキーは将来追加される可能性があるため、
  存在しないキーへのアクセスは context.get('key') を使用すること。

--------------------------------------------------------------------------------
5. 進捗メッセージの送信
--------------------------------------------------------------------------------

長時間かかる処理では、message_callbackを使って進捗を通知すること:

【実装例】

def execute(args, context):
    callback = context.get('message_callback')
    
    if callback:
        callback("検索を開始しています...")
    
    # 処理...
    
    if callback:
        callback("結果を整理しています...")
    
    return {"success": True, "result": data}

--------------------------------------------------------------------------------
6. 中断処理への対応
--------------------------------------------------------------------------------

abort_eventを定期的にチェックし、中断要求に応答すること:

【実装例】

def execute(args, context):
    abort_event = context.get('abort_event')
    
    for item in large_list:
        if abort_event and abort_event.is_set():
            return {"success": False, "error": "中断されました", "aborted": True}
        
        # 処理...
    
    return {"success": True, "result": results}

--------------------------------------------------------------------------------
7. オプション機能
--------------------------------------------------------------------------------

【設定スキーマ】
ツールに設定項目がある場合、以下の関数を実装:

def get_settings_schema() -> dict:
    """
    ツールの設定スキーマを返す。
    
    Returns:
        dict: 設定項目の定義
    """
    return {
        "api_key": {
            "type": "string",
            "label": "APIキー",
            "default": "",
            "secret": True
        },
        "max_results": {
            "type": "integer",
            "label": "最大結果数",
            "default": 10,
            "min": 1,
            "max": 100
        }
    }

【UI情報】
ツールにWebUIがある場合:

def get_ui_info() -> dict:
    """
    ツールのUI情報を返す。
    
    Returns:
        dict: UI設定
    """
    return {
        "has_ui": True,
        "html_file": "index.html"
    }

--------------------------------------------------------------------------------
8. 実装テンプレート
--------------------------------------------------------------------------------

以下は新しいツールを作成する際のテンプレートです:

"""
[ツール名]ツール
[ツールの説明]
"""

TOOL_NAME = "ツール表示名"
TOOL_DESCRIPTION = "ツールの説明文"
TOOL_ICON = "🔧"


def get_function_declaration() -> dict:
    """Function Calling用の宣言を返す"""
    return {
        "name": "tool_function_name",
        "description": "この関数の説明",
        "parameters": {
            "type": "object",
            "properties": {
                "param1": {
                    "type": "string",
                    "description": "パラメータ1の説明"
                },
                "param2": {
                    "type": "integer",
                    "description": "パラメータ2の説明"
                }
            },
            "required": ["param1"]
        }
    }


def execute(args: dict, context: dict) -> dict:
    """ツールを実行する"""
    # コンテキストから必要な情報を取得
    callback = context.get('message_callback')
    abort_event = context.get('abort_event')
    settings = context.get('settings', {})
    
    try:
        # 進捗通知
        if callback:
            callback("処理を開始しています...")
        
        # 中断チェック
        if abort_event and abort_event.is_set():
            return {"success": False, "error": "中断されました", "aborted": True}
        
        # メイン処理
        param1 = args.get('param1', '')
        param2 = args.get('param2', 0)
        
        # ... 実際の処理 ...
        
        result = {"data": "処理結果"}
        
        return {
            "success": True,
            "result": result
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


# オプション: 設定スキーマ
def get_settings_schema() -> dict:
    """設定スキーマを返す"""
    return {
        "setting_key": {
            "type": "string",
            "label": "設定項目名",
            "default": "デフォルト値"
        }
    }


# オプション: UI情報
def get_ui_info() -> dict:
    """UI情報を返す"""
    return {
        "has_ui": False,
        "html_file": "index.html"
    }

--------------------------------------------------------------------------------
9. 戻り値の形式
--------------------------------------------------------------------------------

execute関数の戻り値は以下の形式に従うこと:

【成功時】
{
    "success": True,
    "result": Any,           # 結果データ（文字列、辞書、リストなど）
    "files": [               # 生成されたファイル（任意）
        {
            "path": str,     # ファイルパス
            "name": str,     # ファイル名
            "type": str      # MIMEタイプ
        }
    ]
}

【失敗時】
{
    "success": False,
    "error": str             # エラーメッセージ
}

【中断時】
{
    "success": False,
    "error": "中断されました",
    "aborted": True
}

--------------------------------------------------------------------------------
10. 注意事項
--------------------------------------------------------------------------------

1. ツール名（TOOL_NAME）は日本語でも可だが、関数名（get_function_declaration
   のname）は英数字とアンダースコアのみを使用すること。

2. 長時間かかる処理では、必ずabort_eventをチェックすること。

3. 外部APIを使用する場合は、APIキーを設定スキーマで定義し、
   context['settings']から取得すること。

4. ファイルを生成する場合は、tool_dir内に保存し、戻り値のfilesに
   絶対パスを含めること。

5. エラーが発生した場合は、ユーザーにわかりやすいエラーメッセージを
   返すこと。

6. 依存ライブラリがある場合は、requirements.txtに記載すること。
   仮想環境は自動的に作成・管理される。

================================================================================
